export const OutlineViewerHtml = "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Leo Document Viewer</title>\r\n    <link rel=\"icon\" type=\"image/x-icon\"\r\n        href=\"data:image/x-icon;base64,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\">\r\n    <style>\r\n        :root {\r\n            /* light theme (default) */\r\n            --background-color: #ffffec;\r\n            --body-pane-color: #fff6f5;\r\n            --body-link-color: #5178ab;\r\n            --find-pane-color: #f9f9f9;\r\n            --resizer-color: #cae1ff;\r\n            --selected-bg: #cae1ff;\r\n            --ancestor-bg: #eef5ff;\r\n            --hover-bg: #dfecff;\r\n            --focus-outline: #0000ff;\r\n            --text-color: #000000;\r\n            --caret-dim-color: #888;\r\n            --find-text-color: #444;\r\n            --find-placeholder-color: #888;\r\n            --find-border-color: #a0a0a0;\r\n            --find-selection: #0078d7;\r\n            /* vertical layout (default) */\r\n            --main-direction: row;\r\n            --main-resizer-width: 5px;\r\n            --main-resizer-height: 100%;\r\n            --main-resizer-cursor: ew-resize;\r\n            --main-resizer-extension-width: 5px;\r\n            --main-resizer-extension-height: 100%;\r\n            --main-resizer-before-top: unset;\r\n            --main-resizer-before-left: -5px;\r\n            --main-resizer-after-right: -5px;\r\n            --main-resizer-after-bottom: unset;\r\n            --cross-resizer-size: 5px;\r\n            --secondary-direction: column;\r\n            --secondary-height: 100%;\r\n            --secondary-resizer-width: 100%;\r\n            --secondary-resizer-height: 5px;\r\n            --secondary-resizer-cursor: ns-resize;\r\n            --secondary-resizer-extension-width: 100%;\r\n            --secondary-resizer-extension-height: 5px;\r\n            --secondary-resizer-before-top: -5px;\r\n            --secondary-resizer-before-left: unset;\r\n            --secondary-resizer-after-right: unset;\r\n            --secondary-resizer-after-bottom: -5px;\r\n            /* transitions */\r\n            --body-transition: unset;\r\n            --body-pane-transition: unset;\r\n            --find-pane-transition: unset;\r\n            /* configuration/find pane visibility */\r\n            --config-display: none;\r\n            --find-display: flex;\r\n        }\r\n\r\n        [data-show-config=\"true\"] {\r\n            --config-display: flex;\r\n            --find-display: none;\r\n        }\r\n\r\n        [data-transition=\"true\"] {\r\n            --body-transition: color 0.15s ease, background-color 0.15s ease;\r\n            --body-pane-transition: color 0.3s ease, background-color 0.3s ease;\r\n            --find-pane-transition: color 0.15s ease, background-color 0.15s ease;\r\n        }\r\n\r\n        [data-theme=\"dark\"] {\r\n            --background-color: #1e1e2e;\r\n            --body-pane-color: #2a2536;\r\n            --body-link-color: #929bda;\r\n            --find-pane-color: #23202e;\r\n            --resizer-color: #454a6e;\r\n            --selected-bg: #454a6e;\r\n            --ancestor-bg: #2d3250;\r\n            --hover-bg: #3a3f5e;\r\n            --focus-outline: #7aa2f7;\r\n            --text-color: #cdd6f4;\r\n            --caret-dim-color: #999;\r\n            --find-text-color: #aeb6d1;\r\n            --find-placeholder-color: #5a699e;\r\n            --find-border-color: #81889e;\r\n            --find-selection: #3c54ce;\r\n        }\r\n\r\n        [data-layout=\"horizontal\"] {\r\n            --main-direction: column;\r\n            --main-resizer-width: 100%;\r\n            --main-resizer-height: 5px;\r\n            --main-resizer-cursor: ns-resize;\r\n            --main-resizer-extension-width: 100%;\r\n            --main-resizer-extension-height: 5px;\r\n            --main-resizer-before-top: -5px;\r\n            --main-resizer-before-left: unset;\r\n            --main-resizer-after-right: unset;\r\n            --main-resizer-after-bottom: -5px;\r\n            --secondary-direction: row;\r\n            --secondary-height: 100%;\r\n            --secondary-resizer-width: 5px;\r\n            --secondary-resizer-height: 100%;\r\n            --secondary-resizer-cursor: ew-resize;\r\n            --secondary-resizer-extension-width: 5px;\r\n            --secondary-resizer-extension-height: 100%;\r\n            --secondary-resizer-before-top: unset;\r\n            --secondary-resizer-before-left: -5px;\r\n            --secondary-resizer-after-right: -5px;\r\n            --secondary-resizer-after-bottom: unset;\r\n        }\r\n\r\n        /* Custom scrollbars */\r\n        * {\r\n            /* Firefox */\r\n            scrollbar-color: var(--resizer-color) transparent;\r\n        }\r\n\r\n        /* Chrome, Edge, Safari */\r\n        ::-webkit-scrollbar {\r\n            width: 5px;\r\n            height: 5px;\r\n        }\r\n\r\n        ::-webkit-scrollbar-track {\r\n            background: transparent;\r\n            border-radius: 5px;\r\n        }\r\n\r\n        ::-webkit-scrollbar-thumb {\r\n            background-color: var(--resizer-color);\r\n            border-radius: 5px;\r\n        }\r\n\r\n        ::-webkit-scrollbar-thumb:hover {\r\n            background-color: var(--hover-bg);\r\n        }\r\n\r\n        .icon0 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/></svg>');\r\n        }\r\n\r\n        .icon1 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\r\n        }\r\n\r\n        .icon2 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/></svg>');\r\n        }\r\n\r\n        .icon3 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\">   <path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\r\n        }\r\n\r\n        .icon4 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\r\n        }\r\n\r\n        .icon5 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\r\n        }\r\n\r\n        .icon6 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\r\n        }\r\n\r\n        .icon7 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%234d4d4d\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\r\n        }\r\n\r\n        .icon8 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/></svg>');\r\n        }\r\n\r\n        .icon9 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\r\n        }\r\n\r\n        .icon10 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/></svg>');\r\n        }\r\n\r\n        .icon11 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/></svg>');\r\n        }\r\n\r\n        .icon12 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\r\n        }\r\n\r\n        .icon13 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\r\n        }\r\n\r\n        .icon14 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\r\n        }\r\n\r\n        .icon15 {\r\n            background-image: url('data:image/svg+xml;utf8, <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"none\"><path d=\"M7.074 4.5v8h1v-8z\" fill=\"%23e54a16\"/><path d=\"M0 4v9h15.15V4zm1 1h13.15v7H1z\" fill=\"%23a4a59e\"/><path d=\"M9.075 6v5h4.075V6zm1 1h2.076v3h-2.076z\" fill=\"%2342a5f5\"/><path d=\"M3.56 5.65v2h1v-.279a1.5 1.5 0 11-2.27 1.904l-.923.395A2.5 2.5 0 006.074 8.5a2.5 2.5 0 00-.824-1.85h.31v-1z\" fill=\"%23e54a16\"/></svg>');\r\n        }\r\n\r\n        body {\r\n            margin: 0;\r\n            display: flex;\r\n            flex-direction: var(--main-direction);\r\n            height: 100vh;\r\n            background-color: var(--background-color);\r\n            color: var(--text-color);\r\n            transition: var(--body-transition)\r\n        }\r\n\r\n        body.dragging-main {\r\n            cursor: var(--main-resizer-cursor) !important;\r\n        }\r\n\r\n        body.dragging-secondary {\r\n            cursor: var(--secondary-resizer-cursor) !important;\r\n        }\r\n\r\n        #outline-pane {\r\n            position: relative;\r\n            white-space: nowrap;\r\n            padding-top: 6px;\r\n            overflow-x: hidden;\r\n            overflow-y: auto;\r\n            font-family: sans-serif;\r\n        }\r\n\r\n        #spacer {\r\n            position: relative;\r\n        }\r\n\r\n        #collapse-all-btn {\r\n            position: fixed;\r\n            z-index: 100;\r\n            opacity: 0;\r\n            transition: opacity 0.2s ease;\r\n            pointer-events: none;\r\n        }\r\n\r\n        #outline-pane:hover #collapse-all-btn {\r\n            opacity: 1;\r\n            pointer-events: auto;\r\n        }\r\n\r\n        .outline-icon {\r\n            display: inline-flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            cursor: pointer;\r\n            width: 16px;\r\n            height: 16px;\r\n        }\r\n\r\n        .outline-icon:hover svg {\r\n            transform: scale(1.1);\r\n            transition: transform 0.1s ease;\r\n        }\r\n\r\n        #main-resizer {\r\n            position: relative;\r\n            width: var(--main-resizer-width);\r\n            height: var(--main-resizer-height);\r\n            cursor: var(--main-resizer-cursor);\r\n            background-color: var(--resizer-color);\r\n            flex-shrink: 0;\r\n        }\r\n\r\n        #main-resizer::before,\r\n        #main-resizer::after {\r\n            content: \"\";\r\n            position: absolute;\r\n            height: var(--main-resizer-extension-height);\r\n            width: var(--main-resizer-extension-width);\r\n            cursor: var(--main-resizer-cursor);\r\n        }\r\n\r\n        #main-resizer::before {\r\n            top: var(--main-resizer-before-top);\r\n            left: var(--main-resizer-before-left)\r\n        }\r\n\r\n        #main-resizer::after {\r\n            right: var(--main-resizer-after-right);\r\n            bottom: var(--main-resizer-after-bottom)\r\n        }\r\n\r\n        #outline-find-container {\r\n            display: flex;\r\n            flex-direction: var(--secondary-direction);\r\n            height: var(--secondary-height);\r\n            overflow: hidden;\r\n        }\r\n\r\n        #secondary-resizer {\r\n            position: relative;\r\n            height: var(--secondary-resizer-height);\r\n            width: var(--secondary-resizer-width);\r\n            cursor: var(--secondary-resizer-cursor);\r\n            background-color: var(--resizer-color);\r\n            flex-shrink: 0;\r\n        }\r\n\r\n        #secondary-resizer::before,\r\n        #secondary-resizer::after {\r\n            content: \"\";\r\n            position: absolute;\r\n            width: var(--secondary-resizer-extension-width);\r\n            height: var(--secondary-resizer-extension-height);\r\n            cursor: var(--secondary-resizer-cursor);\r\n        }\r\n\r\n        #secondary-resizer::before {\r\n            top: var(--secondary-resizer-before-top);\r\n            left: var(--secondary-resizer-before-left);\r\n        }\r\n\r\n        #secondary-resizer::after {\r\n            bottom: var(--secondary-resizer-after-bottom);\r\n            right: var(--secondary-resizer-after-right);\r\n        }\r\n\r\n        #cross-resizer {\r\n            position: absolute;\r\n            top: 200px;\r\n            left: 200px;\r\n            width: var(--cross-resizer-size);\r\n            height: var(--cross-resizer-size);\r\n            cursor: move;\r\n            background-color: transparent;\r\n            flex-shrink: 0;\r\n        }\r\n\r\n        #cross-resizer::after {\r\n            content: \"\";\r\n            position: absolute;\r\n            top: -5px;\r\n            left: -5px;\r\n            width: 15px;\r\n            height: 15px;\r\n            cursor: move;\r\n        }\r\n\r\n        #outline-pane,\r\n        #find-pane {\r\n            overflow-y: auto;\r\n            flex: 1 1 0;\r\n        }\r\n\r\n        #body-pane {\r\n            flex: 1;\r\n            padding: 1rem 0 0 1rem;\r\n            background-color: var(--body-pane-color);\r\n            overflow-y: auto;\r\n            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\r\n            white-space: pre-wrap;\r\n            transition: var(--body-pane-transition);\r\n        }\r\n\r\n        #body-pane a {\r\n            color: var(--body-link-color);\r\n        }\r\n\r\n        #outline-pane:focus,\r\n        #body-pane:focus,\r\n        #outline-pane:focus-visible,\r\n        #body-pane:focus-visible {\r\n            /* \r\n                Note: Outline will appear under the items positioned absolutely.\r\n                See pseudo-elements with \"z-index: -1\" that appear below this outline.\r\n             */\r\n            outline: 3px solid var(--focus-outline);\r\n            outline-offset: -3px;\r\n        }\r\n\r\n        .node-text:hover::before,\r\n        .selected>.node-text::before,\r\n        .ancestor>.node-text::before,\r\n        .initial-find>.node-text::before {\r\n            content: \"\";\r\n            position: absolute;\r\n            top: 0;\r\n            left: -2px;\r\n            right: 0;\r\n            bottom: 0;\r\n            z-index: -1;\r\n            border-radius: 4px;\r\n        }\r\n\r\n        .selected>.node-text::before,\r\n        .selected>.node-text:hover::before {\r\n            background-color: var(--selected-bg);\r\n        }\r\n\r\n        .ancestor>.node-text::before {\r\n            background-color: var(--ancestor-bg);\r\n        }\r\n\r\n        .node-text:hover::before {\r\n            background-color: var(--hover-bg);\r\n        }\r\n\r\n        .initial-find>.node-text::before {\r\n            border: 1.5px solid var(--find-selection);\r\n            border-style: dotted;\r\n        }\r\n\r\n        .node {\r\n            position: absolute;\r\n            white-space: nowrap;\r\n            cursor: pointer;\r\n            display: grid;\r\n            grid-template-columns: 1em 1fr;\r\n            align-items: start;\r\n        }\r\n\r\n        body.dragging-main .node {\r\n            cursor: var(--main-resizer-cursor);\r\n        }\r\n\r\n        body.dragging-secondary .node {\r\n            cursor: var(--secondary-resizer-cursor);\r\n        }\r\n\r\n        .caret {\r\n            grid-column: 1;\r\n            display: inline-block;\r\n            width: 32px;\r\n            height: 26px;\r\n            position: relative;\r\n            left: -16px;\r\n            user-select: none;\r\n        }\r\n\r\n        .node-text {\r\n            position: relative;\r\n            background-repeat: no-repeat;\r\n            background-position-x: 2px;\r\n            background-position-y: 1px;\r\n            background-size: 19px 19px;\r\n            grid-column: 2;\r\n            display: block;\r\n            padding: 2px 0 2px 26px;\r\n            margin-right: 1.2rem;\r\n            border-radius: 4px;\r\n        }\r\n\r\n        /* Special handling for node icons */\r\n        [data-show-icons=\"false\"] .node-text {\r\n            background-image: none !important;\r\n            padding-left: 4px !important;\r\n            /* Reduce padding when icons are hidden */\r\n        }\r\n\r\n        .caret::after {\r\n            display: inline-block;\r\n            position: relative;\r\n            left: 16px;\r\n            transform-origin: 50% 50%;\r\n            transition: transform 160ms cubic-bezier(.2, .9, .3, 1), color 120ms;\r\n        }\r\n\r\n        .caret[data-expanded=\"true\"]::after {\r\n            content: \"❯\";\r\n            transform: rotate(90deg);\r\n        }\r\n\r\n        .caret[data-expanded=\"false\"]::after {\r\n            content: \"❯\";\r\n            transform: rotate(0deg);\r\n            color: var(--caret-dim-color);\r\n        }\r\n\r\n        .caret.toggled[data-expanded=\"true\"]::after {\r\n            content: \"❯\";\r\n            transform: rotate(90deg);\r\n            animation: rotateOpen 120ms ease-out;\r\n        }\r\n\r\n        .caret.toggled[data-expanded=\"false\"]::after {\r\n            content: \"❯\";\r\n            transform: rotate(0deg);\r\n            color: var(--caret-dim-color);\r\n            animation: rotateClose 120ms ease-out;\r\n        }\r\n\r\n        @keyframes rotateOpen {\r\n            from {\r\n                transform: rotate(0deg);\r\n                color: var(--caret-dim-color);\r\n            }\r\n\r\n            to {\r\n                transform: rotate(90deg);\r\n                color: inherit;\r\n            }\r\n        }\r\n\r\n        @keyframes rotateClose {\r\n            from {\r\n                transform: rotate(90deg);\r\n                color: inherit;\r\n            }\r\n\r\n            to {\r\n                transform: rotate(0deg);\r\n                color: var(--caret-dim-color);\r\n            }\r\n        }\r\n\r\n        /* buttons */\r\n        #button-container {\r\n            position: fixed;\r\n            top: 0px;\r\n            right: 12px;\r\n            padding-top: 8px;\r\n            display: flex;\r\n            flex-direction: row-reverse;\r\n            justify-content: flex-start;\r\n            gap: 8px;\r\n            z-index: 1000;\r\n            transition: opacity 0.4s ease;\r\n            pointer-events: auto;\r\n        }\r\n\r\n        #button-container.hidden {\r\n            opacity: 0;\r\n            pointer-events: none;\r\n        }\r\n\r\n        #button-trigger-area {\r\n            position: fixed;\r\n            top: 0;\r\n            right: 0;\r\n            width: 200px;\r\n            height: 40px;\r\n            z-index: 999;\r\n        }\r\n\r\n        .action-button {\r\n            width: 32px;\r\n            height: 32px;\r\n            border-radius: 50%;\r\n            background: var(--resizer-color);\r\n            color: var(--text-color);\r\n            border: 2px solid var(--text-color);\r\n            cursor: pointer;\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            font-size: 18px;\r\n            line-height: 1;\r\n            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\r\n            z-index: 1000;\r\n            overflow: hidden;\r\n            transition: transform 0.2s ease;\r\n            user-select: none;\r\n        }\r\n\r\n        .action-button:hover {\r\n            transform: scale(1.1);\r\n        }\r\n\r\n        .action-button:disabled {\r\n            opacity: 0.4;\r\n            cursor: default;\r\n            box-shadow: none;\r\n            border-color: var(--caret-dim-color);\r\n        }\r\n\r\n        .action-button:disabled:hover {\r\n            transform: none;\r\n        }\r\n\r\n        .svg-icon {\r\n            position: relative;\r\n            top: 0;\r\n            left: 0;\r\n            transition: top 0.3s ease, left 0.3s ease, transform 0.3s ease;\r\n        }\r\n\r\n        #dehoist-btn:active #dehoist-icon {\r\n            top: -10px;\r\n        }\r\n\r\n        #hoist-btn:active #hoist-icon {\r\n            top: 10px;\r\n        }\r\n\r\n        #prev-btn:active #prev-icon {\r\n            left: -10px;\r\n        }\r\n\r\n        #next-btn:active #next-icon {\r\n            left: 10px;\r\n        }\r\n\r\n        #toggle-icon {\r\n            position: relative;\r\n            top: 0;\r\n            transition: top 0.3s ease;\r\n        }\r\n\r\n        #theme-toggle:active #toggle-icon {\r\n            top: 25px;\r\n        }\r\n\r\n        #layout-icon {\r\n            position: relative;\r\n            top: 0;\r\n        }\r\n\r\n        [data-layout=\"horizontal\"] #layout-icon {\r\n            transform: rotate(90deg);\r\n        }\r\n\r\n        [data-transition=\"true\"] #layout-icon {\r\n            transition: transform 0.3s ease;\r\n        }\r\n\r\n        .svg-icon svg {\r\n            display: block;\r\n            width: 20px;\r\n            height: 20px;\r\n        }\r\n\r\n        .action-button:disabled:active #toggle-icon,\r\n        .action-button:disabled:active #dehoist-icon,\r\n        .action-button:disabled:active #hoist-icon {\r\n            top: 0 !important;\r\n        }\r\n\r\n        .action-button:disabled:active #prev-icon,\r\n        .action-button:disabled:active #next-icon {\r\n            left: 0 !important;\r\n        }\r\n\r\n        #toggle-mark-btn:active #toggle-mark-icon {\r\n            transform: scale(0.7);\r\n        }\r\n\r\n        #prev-marked-btn:active #prev-marked-icon {\r\n            left: -10px;\r\n        }\r\n\r\n        #next-marked-btn:active #next-marked-icon {\r\n            left: 10px;\r\n        }\r\n\r\n        .hidden-button {\r\n            display: none !important;\r\n        }\r\n\r\n        /* find pane */\r\n        #find-pane {\r\n            scrollbar-gutter: stable;\r\n            font-family: sans-serif;\r\n            padding: 0.5rem 0 0 0.5rem;\r\n            overflow-x: hidden;\r\n            background-color: var(--find-pane-color);\r\n            position: relative;\r\n            transition: var(--find-pane-transition);\r\n            container-type: inline-size;\r\n            container-name: find-pane;\r\n        }\r\n\r\n        #find-controls,\r\n        #config-controls {\r\n            gap: 0.5rem;\r\n            align-items: flex-start;\r\n            flex-wrap: wrap;\r\n        }\r\n\r\n        @container find-pane (min-width: 450px) {\r\n            #config-controls {\r\n                justify-content: center;\r\n            }\r\n        }\r\n\r\n        #config-btn {\r\n            position: fixed;\r\n            z-index: 2001;\r\n            cursor: pointer;\r\n            font-size: 20px;\r\n            opacity: 0.6;\r\n            transition: transform 0.2s ease, opacity 0.2s ease;\r\n            text-shadow: 0 3px 3px rgba(0, 0, 0, 0.4);\r\n            user-select: none;\r\n        }\r\n\r\n        #config-btn:hover {\r\n            transform: scale(1.2);\r\n            opacity: 1;\r\n        }\r\n\r\n        #find-controls {\r\n            padding-top: 0.5rem;\r\n            display: var(--find-display);\r\n        }\r\n\r\n        #config-controls {\r\n            padding-top: 0;\r\n            display: var(--config-display);\r\n        }\r\n\r\n        .config-title {\r\n            cursor: default;\r\n            user-select: none;\r\n            width: 100%;\r\n            text-align: center;\r\n            font-weight: bold;\r\n            margin: 0;\r\n            font-size: 1em;\r\n            color: var(--find-text-color);\r\n        }\r\n\r\n        .config-title svg {\r\n            vertical-align: middle;\r\n        }\r\n\r\n        .sub-title {\r\n            width: 100%;\r\n            text-align: center;\r\n            margin: 0;\r\n            color: var(--caret-dim-color);\r\n            font-style: italic;\r\n            font-size: 0.9em;\r\n            cursor: default;\r\n            user-select: none;\r\n        }\r\n\r\n        #find-pane .config-col.shortcuts {\r\n            list-style: none;\r\n            padding: 0;\r\n            margin: -5px 0 0 0;\r\n            font-size: 0.8em;\r\n            color: var(--find-text-color);\r\n            gap: 0;\r\n            min-width: 285px;\r\n            cursor: default;\r\n            user-select: none;\r\n        }\r\n\r\n        #find-pane .config-col.shortcuts li {\r\n            padding: 0.25rem 0.5rem;\r\n            display: flex;\r\n            align-items: center;\r\n        }\r\n\r\n        #find-pane .config-col.shortcuts kbd {\r\n            display: inline-block;\r\n            padding: 0.1rem 0.4rem;\r\n            margin: 0 0.2rem;\r\n            font-family: monospace;\r\n            font-size: 0.9em;\r\n            line-height: 1.4;\r\n            color: var(--text-color);\r\n            background-color: var(--resizer-color);\r\n            border: 1px solid var(--find-border-color);\r\n            border-radius: 3px;\r\n            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2);\r\n        }\r\n\r\n        .kbd-spacer {\r\n            display: inline-block;\r\n            width: 100px;\r\n        }\r\n\r\n        #find-pane .find-col,\r\n        #find-pane .config-col {\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 0.35rem;\r\n            min-width: 110px;\r\n        }\r\n\r\n        #find-pane .find-col label,\r\n        #find-pane .config-col label {\r\n            display: inline-flex;\r\n            align-items: center;\r\n            gap: 0.5rem;\r\n            cursor: pointer;\r\n            user-select: none;\r\n            font-size: 0.8em;\r\n            color: var(--find-text-color);\r\n        }\r\n\r\n        .config-col label {\r\n            padding-left: 0.5rem;\r\n        }\r\n\r\n        #find-pane input[type=\"checkbox\"],\r\n        #find-pane input[type=\"radio\"] {\r\n            flex-shrink: 0;\r\n            width: 16px;\r\n            height: 16px;\r\n            margin: 0;\r\n        }\r\n\r\n        #find-input {\r\n            width: 100%;\r\n            /* max-width: 260px; */\r\n            box-sizing: border-box;\r\n            padding: 0.4rem 0.5rem;\r\n            margin: 0;\r\n            border-radius: 3px;\r\n            border: 1px solid var(--find-border-color);\r\n            background: transparent;\r\n            color: var(--find-text-color);\r\n            font-family: sans-serif;\r\n            display: var(--find-display)\r\n        }\r\n\r\n        #find-input::placeholder {\r\n            color: var(--find-placeholder-color);\r\n        }\r\n\r\n        input[type=\"checkbox\"] {\r\n            appearance: none;\r\n            width: 20px;\r\n            height: 20px;\r\n            border: 1px solid var(--find-border-color);\r\n            border-radius: 3px;\r\n            background-color: var(--find-pane-color);\r\n            position: relative;\r\n        }\r\n\r\n        input[type=\"checkbox\"]:checked::after {\r\n            content: \"\";\r\n            position: absolute;\r\n            left: 4px;\r\n            top: -2px;\r\n            width: 4px;\r\n            height: 12px;\r\n            border: solid var(--find-border-color);\r\n            border-width: 0 2px 2px 0;\r\n            transform: rotate(45deg);\r\n        }\r\n\r\n        input[type=\"radio\"] {\r\n            appearance: none;\r\n            width: 20px;\r\n            height: 20px;\r\n            border: 1px solid var(--find-border-color);\r\n            border-radius: 50%;\r\n            background-color: var(--find-pane-color);\r\n            position: relative;\r\n        }\r\n\r\n        input[type=\"radio\"]:checked::after {\r\n            content: \"\";\r\n            position: absolute;\r\n            top: 50%;\r\n            left: 50%;\r\n            width: 8px;\r\n            height: 8px;\r\n            transform: translate(-50%, -50%);\r\n            background-color: var(--find-text-color);\r\n            border-radius: 50%;\r\n        }\r\n\r\n        input[type=\"radio\"]:focus:checked::after,\r\n        input[type=\"radio\"]:focus-visible:checked::after {\r\n            background-color: var(--find-selection);\r\n        }\r\n\r\n        input[type=\"checkbox\"]:focus:checked::after,\r\n        input[type=\"checkbox\"]:focus-visible:checked::after {\r\n            border: solid var(--find-selection);\r\n            border-width: 0 2px 2px 0;\r\n        }\r\n\r\n        #find-pane input:focus,\r\n        #find-pane input:focus-visible {\r\n            border-color: var(--find-selection);\r\n            outline: 2px solid var(--find-selection);\r\n            outline-offset: -1px;\r\n        }\r\n\r\n        a {\r\n            color: var(--caret-dim-color);\r\n            text-decoration: underline;\r\n        }\r\n\r\n        a:hover {\r\n            color: var(--find-text-color);\r\n        }\r\n\r\n        .footer {\r\n            margin-bottom: 1rem;\r\n        }\r\n\r\n        /* context menu */\r\n        .context-menu {\r\n            position: absolute;\r\n            display: none;\r\n            font-family: sans-serif;\r\n            font-size: 0.85rem;\r\n            background: var(--find-pane-color);\r\n            border: 1px solid var(--find-border-color);\r\n            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);\r\n            border-radius: 4px;\r\n            z-index: 1000;\r\n        }\r\n\r\n        .context-menu ul {\r\n            list-style: none;\r\n            margin: 0;\r\n            padding: 4px 0;\r\n        }\r\n\r\n        .context-menu li {\r\n            padding: 6px 12px;\r\n            cursor: pointer;\r\n        }\r\n\r\n        .context-menu li:hover {\r\n            background: var(--hover-bg);\r\n        }\r\n\r\n        /* toast */\r\n        #toast {\r\n            position: fixed;\r\n            top: 16px;\r\n            left: 50%;\r\n            transform: translateX(-50%) translateY(-10px);\r\n            background: var(--body-pane-color);\r\n            color: var(--find-text-color);\r\n            padding: 8px 12px;\r\n            border-radius: 6px;\r\n            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);\r\n            opacity: 0;\r\n            pointer-events: none;\r\n            transition: opacity 180ms ease, transform 180ms ease;\r\n            z-index: 2000;\r\n            font-family: sans-serif;\r\n            font-size: 13px;\r\n            white-space: pre;\r\n        }\r\n\r\n        #toast.show {\r\n            opacity: 1;\r\n            transform: translateX(-50%) translateY(0);\r\n            pointer-events: auto;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body>\r\n    <!--\r\n        * Layout *\r\n        The body element is split in two (outline-find-container and body-pane) by the main-resizer.\r\n        The outline-find-container is split in two (outline-pane and find-pane) by the secondary-resizer.\r\n        So in total, there are three panes and two resizers. The rest are just floating buttons which are not part of the layout.\r\n    -->\r\n    <div id=\"outline-find-container\">\r\n        <div id=\"outline-pane\" tabindex=\"0\">\r\n            <div id=\"spacer\"></div>\r\n            <div id=\"collapse-all-btn\" class=\"outline-icon\" title=\"Collapse All\" role=\"button\"\r\n                aria-label=\"Collapse All\">\r\n                <svg width=\"16\" height=\"16\" fill=\"currentColor\">\r\n                    <path\r\n                        d=\"M 6 2 L 5 3 L 5 5 L 3 5 L 2 6 L 2 13 L 3 14 L 10 14 L 11 13 L 11 11 L 13 11 L 14 10 L 14 3 L 13 2 L 6 2 z M 6 3 L 13 3 L 13 10 L 11 10 L 11 6 L 10 5 L 6 5 L 6 3 z M 3 6 L 10 6 L 10 13 L 3 13 L 3 6 z M 4 9 L 4 10 L 9 10 L 9 9 L 4 9 z \"\r\n                        style=\"fill:var(--find-border-color);\" />\r\n                </svg>\r\n            </div>\r\n        </div>\r\n        <div id=\"secondary-resizer\"></div>\r\n        <div id=\"find-pane\">\r\n            <input id=\"find-input\" type=\"text\" autocomplete=\"off\" placeholder=\"&lt;find pattern here&gt;\"\r\n                title=\"Ctrl+F: Search | F3/F2: Next/Prev\" aria-label=\"Find pattern\">\r\n            <div id=\"find-controls\" role=\"region\" aria-label=\"Find options\">\r\n                <div class=\"find-col\" aria-label=\"Search options\">\r\n                    <label for=\"opt-whole\">\r\n                        <input id=\"opt-whole\" type=\"checkbox\" name=\"find-option\" />\r\n                        Whole Word\r\n                    </label>\r\n                    <label for=\"opt-ignorecase\">\r\n                        <input id=\"opt-ignorecase\" type=\"checkbox\" name=\"find-option\" checked />\r\n                        Ignore Case\r\n                    </label>\r\n                    <label for=\"opt-regexp\">\r\n                        <input id=\"opt-regexp\" type=\"checkbox\" name=\"find-option\" />\r\n                        Regexp\r\n                    </label>\r\n                    <label for=\"opt-mark\">\r\n                        <input id=\"opt-mark\" type=\"checkbox\" name=\"find-option\" />\r\n                        Mark Finds\r\n                    </label>\r\n                </div>\r\n                <div class=\"find-col\" role=\"radiogroup\" aria-label=\"Search scope\">\r\n                    <label for=\"scope-entire\">\r\n                        <input id=\"scope-entire\" type=\"radio\" name=\"find-scope\" value=\"entire\" checked />\r\n                        Entire Outline\r\n                    </label>\r\n                    <label for=\"scope-suboutline\">\r\n                        <input id=\"scope-suboutline\" type=\"radio\" name=\"find-scope\" value=\"suboutline\" />\r\n                        Suboutline Only\r\n                    </label>\r\n                    <label for=\"scope-node\">\r\n                        <input id=\"scope-node\" type=\"radio\" name=\"find-scope\" value=\"node\" />\r\n                        Node Only\r\n                    </label>\r\n                    <label for=\"opt-headline\">\r\n                        <input id=\"opt-headline\" type=\"checkbox\" name=\"find-target\" checked />\r\n                        Search Headline\r\n                    </label>\r\n                    <label for=\"opt-body\">\r\n                        <input id=\"opt-body\" type=\"checkbox\" name=\"find-target\" checked />\r\n                        Search Body\r\n                    </label>\r\n                </div>\r\n            </div>\r\n            <span id=\"config-btn\" aria-label=\"Configuration\" title=\"Configuration\">⚙️</span>\r\n            <div id=\"config-controls\" role=\"region\" aria-label=\"Configuration settings\">\r\n                <span class=\"config-title\">\r\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" height=\"32\" width=\"32\" viewBox=\"0 0 16 16\">\r\n                        <path d=\"M2.875 1.21h10.566v8.482H2.875z\" fill=\"#7c2504\" />\r\n                        <path\r\n                            d=\"M11.093 1.21c-1.14.782-1.827 2.105-1.828 3.523 0 1.747 1.023 3.246 2.482 3.89v6.021h1.694V1.21zm-8.218 0V14.88h1.713V9.009a4.073 4.225 0 003.167-4.115A4.073 4.225 0 005.673 1.21z\"\r\n                            fill=\"#b04620\" />\r\n                        <path\r\n                            d=\"M6.35 6.339c.12.188.21.425.174.645-.245.565-.76 1.076-1.191 1.44-.73.668-1.442.894-2.433.993V4.002C4 4.79 5.58 5.269 6.35 6.339z\"\r\n                            fill=\"#c96b4b\" />\r\n                        <path\r\n                            d=\"M4.332 8.389c-.158 0-.79.316-.79.316l-.65.561h-.07l-.034 3.3.333.28.562-.105c.37-.073.72-.394 1.106-.368 0 0-.368.375-.457.614-.177.595-.124 1.405.334 1.79.25.201.612.202.93.246 1.464-.037 4.222.01 5.74.035.626-.22.74-.879.841-1.422.07-.409.049-.903-.193-1.21-.215-.265-.877-.527-.877-.527s1.117.332 1.68.482c.2.054.601.15.601.15l.123-3.844-1.035-.298-1.176.07c-1.934.446-3.108.225-4.914.245l-1.053-.28s-.843-.035-1-.035z\"\r\n                            fill=\"#e4dcc8\" />\r\n                        <path\r\n                            d=\"M4.708 2.514c-.947.022-1.475.03-1.808 1.194-.061.43.13.923.439 1.228.415.386 1.612.462 2.264.738.249.037.546.14.755 0 .277-.202.345-.987.473-1.37.003-.511-.243-1.192-.649-1.597-.477-.294-.98-.212-1.474-.193zm7.065.1c-.2.002-.405.024-.613.036-.518-.066-.748.086-.983.526-.343.738-.604 2.514.21 2.878.915.34 1.406-.481 2.001-.824.271-.149.585-.198.878-.299.049-1.108.161-1.483-.51-2.018-.322-.249-.648-.301-.983-.298z\"\r\n                            fill=\"#f9f2b3\" />\r\n                        <path\r\n                            d=\"M2.49.713V10l-1.516.143a.334.334 0 10.063.666l1.453-.138v.59l-1.483.288a.334.334 0 10.127.656l1.356-.263v3.349H13.88v-4.025h1.032a.334.334 0 100-.67h-1.032v-.64l1.054-.108a.334.334 0 10-.067-.665l-.987.101V.713H2.49zm.905.905h9.579v2.411a1.607 1.607 0 00-.088-.224c-.315-.63-.738-.878-1.277-.857-.636.001-1.105.415-1.342 1.009-.152.398-.113.704-.09 1.082.016.24.4.593.692.537.453-.088 1.18-.482 1.757-.765.18-.088.289-.19.348-.303v4.869l-2.427.246a.334.334 0 10.067.665l2.36-.24v.549h-2.405a.334.334 0 100 .669h2.405v3.12H3.395v-.677c.117.087.348.15.436.11.33-.153.357-.46.749-.83.182-.171.323-.42.599-.562.246-.126.727-.052 1.452-.207 1.346-.232 2.858-.122 3.97.085.707.134.891.457 1.033.776.11.248.07.353.247.558.137.16.505.353.716.169.168-.147 0-.502.182-.682.204-.204.28-.442.007-.745-.902-.485-1.542-.586-2.66-.737-.199-.02-.316-.245-.461-.38-.345-.32-.675-.483-1.103-.532.016-.055.037-.204.068-.244.695-.897 1.659-1.467 2.392-1.634.273-.062.157-.392.093-.431-.145-.088-.331-.093-.5-.093-.319.001-.633.08-.95.098-.952.054-1.783.082-2.651.006-.287-.025-.576-.058-.864-.046-.463.02-.554.254-.43.598.045.128.579.135.84.272.423.22.632.51 1.103 1.097.058.071.126.137.167.218.023.046.023.1.03.15-.514.002-.712.127-1.025.46-.363.38-.283.403-1.243.553-.22.034-.458.033-.678.069-.413.067-1.056.097-1.375.472-.062.073-.1.14-.143.208v-.719l2.476-.48a.334.334 0 10-.128-.657l-2.348.456v-.5l2.445-.231a.334.334 0 10-.063-.666l-2.382.225v-5.62c.2.094.516.16.657.221.442.194.737.484 1.025.634.18.094.866.282 1.016.147.222-.2.262-1.117.074-1.538a2.12 2.12 0 00-.651-.854c-.09-.072-.43-.153-.68-.148-.25.004-.556.053-.711.091-.315.079-.473.259-.683.505-.012.012-.031.05-.047.076z\"\r\n                            fill=\"#1c0e01\" />\r\n                        <path\r\n                            d=\"M4.487 3.186c-.11.182-.05.382.062.533.094.125.222.226.36.298.222.11.36.162.484-.062.151-.264.091-.52-.112-.72-.23-.204-.581-.277-.794-.05zm7 .26c-.326.03-.478.33-.472.633a.91.91 0 00.162.385c.247-.037.604-.197.769-.36.093-.133.21-.369.149-.509-.152-.191-.403-.18-.608-.149z\"\r\n                            fill=\"#fff\" />\r\n                    </svg>\r\n                    Leo Outline Viewer </span>\r\n                <span class=\"sub-title\">Visible Controls</span>\r\n                <div class=\"config-col\" aria-label=\"Config options\">\r\n                    <label for=\"show-prev-next-history\">\r\n                        <input id=\"show-prev-next-history\" type=\"checkbox\" name=\"config-option\" checked />\r\n                        Previous/Next History\r\n                    </label>\r\n                    <label for=\"show-prev-next-mark\">\r\n                        <input id=\"show-prev-next-mark\" type=\"checkbox\" name=\"config-option\" checked />\r\n                        Previous/Next Marked\r\n                    </label>\r\n                    <label for=\"show-toggle-mark\">\r\n                        <input id=\"show-toggle-mark\" type=\"checkbox\" name=\"config-option\" />\r\n                        Mark/Unmark\r\n                    </label>\r\n                    <label for=\"show-hoist-dehoist\">\r\n                        <input id=\"show-hoist-dehoist\" type=\"checkbox\" name=\"config-option\" />\r\n                        Hoist/De-hoist\r\n                    </label>\r\n                </div>\r\n                <div class=\"config-col\" aria-label=\"Config options\">\r\n                    <label for=\"show-layout-orientation\">\r\n                        <input id=\"show-layout-orientation\" type=\"checkbox\" name=\"config-option\" checked />\r\n                        Layout Orientation\r\n                    </label>\r\n                    <label for=\"show-theme-toggle\">\r\n                        <input id=\"show-theme-toggle\" type=\"checkbox\" name=\"config-option\" checked />\r\n                        Dark/Light Theme\r\n                    </label>\r\n                    <label for=\"show-node-icons\">\r\n                        <input id=\"show-node-icons\" type=\"checkbox\" name=\"config-option\" checked />\r\n                        Node Icons\r\n                    </label>\r\n                    <label for=\"show-collapse-all\">\r\n                        <input id=\"show-collapse-all\" type=\"checkbox\" name=\"config-option\" checked />\r\n                        Collapse All\r\n                    </label>\r\n                    <!-- Future possible options: -->\r\n                    <!-- <label for=\"show-chapters\">\r\n                        <input id=\"show-chapters\" type=\"checkbox\" name=\"config-option\" />\r\n                        Chapters\r\n                    </label> -->\r\n                </div>\r\n                <span class=\"sub-title\">Keyboard Shortcuts</span>\r\n                <ul class=\"config-col shortcuts\">\r\n                    <li><span class=\"kbd-spacer\"><kbd>Arrows</kbd></span> — Navigate Outline</li>\r\n                    <li><span class=\"kbd-spacer\"><kbd>Alt</kbd>+<kbd>Arrows</kbd></span> — Navigate from Body Pane</li>\r\n                    <li><span class=\"kbd-spacer\"><kbd>Ctrl</kbd>+<kbd>F</kbd></span> — Find…</li>\r\n                    <li><span class=\"kbd-spacer\"><kbd>F2</kbd>/<kbd>F3</kbd></span> — Previous/Next Match</li>\r\n                    <li><span class=\"kbd-spacer\"><kbd>Ctrl</kbd>+<kbd>M</kbd></span> — Mark Node</li>\r\n                    <li><span class=\"kbd-spacer\"><kbd>Alt</kbd>+<kbd>-</kbd></span> — Collapse All</li>\r\n                </ul>\r\n                <span class=\"sub-title footer\">\r\n                    <a href=\"https://leo-editor.github.io/leo-editor/\" target=\"_blank\">Leo Editor</a>\r\n                    <span>Outline Viewer - 1.0.3 - Made by</span>\r\n                    <a href=\"https://github.com/boltex\" target=\"_blank\">Félix</a>\r\n                </span>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div id=\"main-resizer\"></div>\r\n    <div id=\"cross-resizer\"></div>\r\n    <div id=\"body-pane\" tabindex=\"0\" contenteditable=\"plaintext-only\" spellcheck=\"false\"></div>\r\n    <div id=\"button-trigger-area\"></div>\r\n    <div id=\"button-container\">\r\n        <button tabindex=\"-1\" id=\"theme-toggle\" class=\"action-button\" aria-label=\"Toggle dark/light mode\"><span\r\n                id=\"toggle-icon\">🌓</span></button>\r\n        <button tabindex=\"-1\" id=\"layout-toggle\" class=\"action-button\" aria-label=\"Toggle layout orientation\"><span\r\n                id=\"layout-icon\">📐</span></button>\r\n        <button tabindex=\"-1\" id=\"dehoist-btn\" class=\"action-button\" aria-label=\"De-hoist\" title=\"De-hoist\" disabled>\r\n            <span class=\"svg-icon\" id=\"dehoist-icon\">\r\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 17 17\">\r\n                    <path\r\n                        d=\"m 9.717,5.896 0.701,1.249 h 3.238 v 6.494 H 2.344 V 9.3649687 L 1.096,10.038969 V 14.896 h 13.808 v -9 z M 3.198,0.844 1.733,8.267 4.326,6.865 6.23,10.258 9.687,8.388 7.78,4.997 10.374,3.596 Z\"\r\n                        style=\"fill:var(--find-text-color);\" />\r\n                </svg>\r\n            </span>\r\n        </button>\r\n        <button tabindex=\"-1\" id=\"hoist-btn\" class=\"action-button\" aria-label=\"Hoist\" title=\"Hoist\">\r\n            <span class=\"svg-icon\" id=\"hoist-icon\">\r\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 17 17\">\r\n                    <path\r\n                        d=\"M 7.907,10.33 3.089,4.496 h 2.947 l 0.062,-3.89 3.93,0.002 -0.065,3.89 2.948,-0.001 z M 1.096,5.896 v 9 h 13.808 v -9 h -0.596094 l -1.07,1.249 H 13.656 v 6.494 H 2.344 V 7.145 h 0.4117139 l -1.031,-1.249 z\"\r\n                        style=\"fill:var(--find-text-color);\" />\r\n                </svg>\r\n            </span>\r\n        </button>\r\n        <button tabindex=\"-1\" id=\"next-marked-btn\" class=\"action-button\" aria-label=\"Go to Next Marked Node\"\r\n            title=\"Go to Next Marked Node\" disabled>\r\n            <span class=\"svg-icon\" id=\"next-marked-icon\">\r\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\r\n                    <polygon points=\"14,10 6,3 6,17\" fill=\"#cb1919\" />\r\n                </svg>\r\n            </span>\r\n        </button>\r\n        <button tabindex=\"-1\" id=\"toggle-mark-btn\" class=\"action-button\" aria-label=\"Toggle Mark\" title=\"Toggle Mark\">\r\n            <span class=\"svg-icon\" id=\"toggle-mark-icon\">\r\n                <svg width=\"20\" height=\"20\" viewBox=\"1.5 1 13 13\">\r\n                    <path\r\n                        d=\"m 5.0855,2.17 c -0.532,0 -0.73,0.196 -0.73,0.728 v 10.933 l 3.645,-2.253 3.644,2.253 V 2.898 c 0,-0.532 -0.197,-0.729 -0.463,-0.7285 z m 3.906,4.088 0.525,1.574 -0.146,0.124 -1.37,-0.976 -1.37,0.976 -0.146,-0.124 0.525,-1.574 -1.356,-0.991 0.066,-0.168 1.676,-0.022 0.51,-1.574 h 0.182 l 0.51,1.574 1.677,0.022 0.08813,0.129125 z\"\r\n                        style=\"fill:#cb1919;\" />\r\n                </svg>\r\n            </span>\r\n        </button>\r\n        <button tabindex=\"-1\" id=\"prev-marked-btn\" class=\"action-button\" aria-label=\"Go to Previous Marked Node\"\r\n            title=\"Go to Previous Marked Node\" disabled>\r\n            <span class=\"svg-icon\" id=\"prev-marked-icon\">\r\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\r\n                    <polygon points=\"6,10 14,3 14,17\" fill=\"#cb1919\" />\r\n                </svg>\r\n            </span>\r\n        </button>\r\n        <button tabindex=\"-1\" id=\"next-btn\" class=\"action-button\" aria-label=\"Goto Next\" title=\"Goto Next\" disabled>\r\n            <span class=\"svg-icon\" id=\"next-icon\">\r\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\r\n                    <polygon points=\"14,10 6,3 6,17\" fill=\"#494\" />\r\n                </svg>\r\n            </span>\r\n        </button>\r\n        <button tabindex=\"-1\" id=\"prev-btn\" class=\"action-button\" aria-label=\"Goto Previous\" title=\"Goto Previous\"\r\n            disabled>\r\n            <span class=\"svg-icon\" id=\"prev-icon\">\r\n                <svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\">\r\n                    <polygon points=\"6,10 14,3 14,17\" fill=\"#494\" />\r\n                </svg>\r\n            </span>\r\n        </button>\r\n    </div>\r\n    <div id=\"menu\" class=\"context-menu\">\r\n        <ul>\r\n            <li id=\"action-mark\">Mark</li>\r\n            <li id=\"action-unmark\">Unmark</li>\r\n            <li id=\"action-hoist\">Hoist</li>\r\n            <li id=\"action-dehoist\">De-Hoist</li>\r\n        </ul>\r\n    </div>\r\n    <div id=\"toast\" role=\"status\" aria-live=\"polite\" hidden></div>\r\n    <script>\r\n        /* Start of data */\r\n        const title = \"Virtual Tree View Demo 2\"; // Also used as key for localstorage save/restore of expanded and marked sets.\r\n        const genTimestamp = \"1234567890\"; // Change this to force reload of saved localstorage data.\r\n        const tree = {\r\n            \"gnx\": 0,\r\n            \"children\": [\r\n                {\r\n                    \"gnx\": 1\r\n                },\r\n                {\r\n                    \"gnx\": 2,\r\n                    \"children\": [\r\n                        {\r\n                            \"gnx\": 3,\r\n                            \"children\": [\r\n                                {\r\n                                    \"gnx\": 4,\r\n                                    \"children\": [\r\n                                        {\r\n                                            \"gnx\": 5\r\n                                        }\r\n                                    ]\r\n                                }\r\n                            ]\r\n                        },\r\n                        {\r\n                            \"gnx\": 3\r\n                        },\r\n                        {\r\n                            \"gnx\": 6\r\n                        },\r\n                        {\r\n                            \"gnx\": 7\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    \"gnx\": 8,\r\n                    \"children\": [\r\n                        {\r\n                            \"gnx\": 9\r\n                        },\r\n                        {\r\n                            \"gnx\": 10\r\n                        },\r\n                        {\r\n                            \"gnx\": 11\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        };\r\n        const data = {\r\n            \"1\": {\r\n                \"headString\": \"first node no body\",\r\n                \"bodyString\": \"\"\r\n            },\r\n            \"2\": {\r\n                \"headString\": \"second node\",\r\n                \"bodyString\": \"@nowrap\\nSome body content\\nmultiple lines\\nblabla blabla blabla blabla\\nend of first body\"\r\n            },\r\n            \"3\": {\r\n                \"headString\": \"First child clone\",\r\n                \"bodyString\": \"@wrap\\nSome child content\\nblabla blabla blabla blablablabla blabla blabla blablablabla blabla blabla blabla\"\r\n            },\r\n            \"4\": {\r\n                \"headString\": \"Child of clone\",\r\n                \"bodyString\": \"Body of the child of a clone!\\nblabla blabla blabla blabla\\nblabla blabla blabla blabla blabla blabla\"\r\n            },\r\n            \"5\": {\r\n                \"headString\": \"Also has child!\",\r\n                \"bodyString\": \"Yep, child of clone also has child!\\n\"\r\n            },\r\n            \"6\": {\r\n                \"headString\": \"trailing newlines\",\r\n                \"bodyString\": \"inside other at same level\\n\\n\"\r\n            },\r\n            \"7\": {\r\n                \"headString\": \"last same level\",\r\n                \"bodyString\": \"Some body text\"\r\n            },\r\n            \"8\": {\r\n                \"headString\": \"third top node no body\",\r\n                \"bodyString\": \"\"\r\n            },\r\n            \"9\": {\r\n                \"headString\": \"third top node child 1\",\r\n                \"bodyString\": \"Some text in child 1\\nblabla\\n\"\r\n            },\r\n            \"10\": {\r\n                \"headString\": \"third top node child 2\",\r\n                \"bodyString\": \"Sample URLs https://example.com and http://example.org for testing links. Here are some more: file://host/path and file:///C:/path and an email mailto:foo@example.com to make sure they all work.\\n\"\r\n            },\r\n            \"11\": {\r\n                \"headString\": \"third top node child 3\",\r\n                \"bodyString\": \"Last node of the tree's natural tree order.\\n\"\r\n            }\r\n        };\r\n        /* End of data */\r\n\r\n        // Note: Also use buildClones and buildParentRefs\r\n        // to add icon member to data entries as needed:\r\n        // hasBody: 1, isMarked: 2, isClone: 4, isDirty: 8\r\n        let allNodesInOrder = []; // Store all nodes in natural tree order (initialized after tree is built)\r\n\r\n        // Build clones when repeated in the tree\r\n        function buildClones(node) {\r\n\r\n            const visitedNodes = {}; // Keys are gnx, values are node references\r\n\r\n            // Helper function for recursion that has access to the visitedNodes object\r\n            function buildClonesWithChildren(node) {\r\n                const gnx = node && node.gnx;\r\n                // Initialize data entry safely if it exists\r\n                if (gnx != null && data[gnx]) {\r\n                    if (!('icon' in data[gnx])) data[gnx].icon = 0;\r\n                }\r\n                if (gnx != null && Object.prototype.hasOwnProperty.call(visitedNodes, gnx)) {\r\n                    // If we've already seen this node, fill its children with JSON stringify/parse for deep copy.\r\n                    node.children = JSON.parse(JSON.stringify(visitedNodes[gnx].children || []));\r\n                    if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) | 4; // set clone bit\r\n                    // Do not recurse into children, they are already built\r\n                } else {\r\n                    if (gnx != null && data[gnx] && data[gnx].bodyString) {\r\n                        data[gnx].icon = (data[gnx].icon || 0) | 1; // set hasBody bit\r\n                    }\r\n                    visitedNodes[gnx] = node;\r\n                    if (node.children) {\r\n                        for (const child of node.children) {\r\n                            buildClonesWithChildren(child);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            buildClonesWithChildren(node); // Start the recursive process\r\n        }\r\n\r\n        // Add parent references to all nodes recursively\r\n        function buildParentRefs(node, parent = null) {\r\n            node.parent = parent;\r\n            if (node.children) {\r\n                for (const child of node.children) {\r\n                    buildParentRefs(child, node); // recurse with current node as parent\r\n                }\r\n            }\r\n        }\r\n\r\n        // Helper function to get all nodes in tree order\r\n        function getAllNodesInTreeOrder(node) {\r\n            const result = [];\r\n            function traverse(n) {\r\n                if (n !== tree) { // Skip the hidden root node itself\r\n                    result.push(n);\r\n                }\r\n                if (n.children) {\r\n                    for (const child of n.children) {\r\n                        traverse(child);\r\n                    }\r\n                }\r\n            }\r\n            traverse(node);\r\n            return result;\r\n        }\r\n\r\n        buildClones(tree);\r\n        buildParentRefs(tree);\r\n        allNodesInOrder = getAllNodesInTreeOrder(tree); // Initialize the global array once\r\n\r\n        let flatRows = null; // Array of nodes currently visible in the outline pane, null at init time to not trigger render\r\n        const expanded = new Set(); // No need to add the root because 'isExpanded' will return true for it\r\n        const marked = new Set(); // Set of gnx (not nodes) that are marked\r\n        let selectedNode = null; // Track the currently selected node\r\n        let initialFindNode = null; // Node where to start the find (null means from the top)\r\n        let currentTheme = 'light'; // Default theme\r\n        let currentLayout = 'vertical'; // Default layout\r\n        let isDragging = false;\r\n        let mainRatio = 0.25; // Default proportion between outline-find-container and body-pane widths (defaults to 1/4)\r\n        let secondaryIsDragging = false;\r\n        let crossIsDragging = false;\r\n        let secondaryRatio = 0.75; // Default proportion between the outline-pane and the find-pane (defaults to 3/4)\r\n        let __toastTimer = null;\r\n        const navigationHistory = [];\r\n        let currentHistoryIndex = -1; // -1 means no history yet\r\n        const hoistStack = []; // Track hoisted nodes\r\n        // Allow http(s)/ftp with '://', file with // or ///, and mailto: without '//'\r\n        const urlRegex = /\\b(?:(?:https?|ftp):\\/\\/|file:\\/\\/\\/?|mailto:)[^\\s<]+/gi;\r\n\r\n        const minWidth = 20;\r\n        const minHeight = 20;\r\n\r\n        const outlinePaneKeyMap = {\r\n            'Enter': () => BODY_PANE.focus(),\r\n            'Tab': () => BODY_PANE.focus(),\r\n            ' ': () => toggleSelected(),\r\n            'ArrowUp': () => selectVisBack(),\r\n            'ArrowDown': () => selectVisNext(),\r\n            'ArrowLeft': () => contractNodeOrGoToParent(),\r\n            'ArrowRight': () => expandNodeAndGoToFirstChild(),\r\n            'PageUp': () => gotoFirstSiblingOrParent(),\r\n            'PageDown': () => gotoLastSiblingOrVisNext(),\r\n            'Home': () => gotoFirstVisibleNode(),\r\n            'End': () => gotoLastVisibleNode()\r\n        };\r\n\r\n        // Elements\r\n        let selectedLabelElement = null; // Track the currently selected label element in the outline pane\r\n        const ROW_HEIGHT = 26;\r\n        const LEFT_OFFSET = 16; // Padding from left edge\r\n        const OUTLINE_FIND_CONTAINER = document.getElementById(\"outline-find-container\");\r\n        const OUTLINE_PANE = document.getElementById(\"outline-pane\");\r\n        const COLLAPSE_ALL_BTN = document.getElementById(\"collapse-all-btn\");\r\n        const SPACER = document.getElementById(\"spacer\");\r\n        const BODY_PANE = document.getElementById(\"body-pane\");\r\n        const VERTICAL_RESIZER = document.getElementById('main-resizer');\r\n        const FIND_PANE = document.getElementById(\"find-pane\");\r\n        const HORIZONTAL_RESIZER = document.getElementById('secondary-resizer');\r\n        const CROSS_RESIZER = document.getElementById('cross-resizer')\r\n\r\n        const THEME_TOGGLE = document.getElementById('theme-toggle');\r\n        const THEME_ICON = document.getElementById('toggle-icon');\r\n        const LAYOUT_TOGGLE = document.getElementById('layout-toggle');\r\n\r\n        const DEHOIST_BTN = document.getElementById('dehoist-btn');\r\n        const HOIST_BTN = document.getElementById('hoist-btn');\r\n        const NEXT_BTN = document.getElementById('next-btn');\r\n        const PREV_BTN = document.getElementById('prev-btn');\r\n\r\n        const NEXT_MARKED_BTN = document.getElementById('next-marked-btn');\r\n        const TOGGLE_MARK_BTN = document.getElementById('toggle-mark-btn');\r\n        const PREV_MARKED_BTN = document.getElementById('prev-marked-btn');\r\n\r\n        const BUTTON_CONTAINER = document.getElementById('button-container');\r\n        const TRIGGER_AREA = document.getElementById('button-trigger-area');\r\n\r\n        const ACTION_MARK = document.getElementById('action-mark');\r\n        const ACTION_UNMARK = document.getElementById('action-unmark');\r\n        const ACTION_HOIST = document.getElementById('action-hoist');\r\n        const ACTION_DEHOIST = document.getElementById('action-dehoist');\r\n\r\n        const FIND_INPUT = document.getElementById('find-input');\r\n        const OPT_HEADLINE = document.getElementById('opt-headline');\r\n        const OPT_BODY = document.getElementById('opt-body');\r\n        const OPT_WHOLE = document.getElementById('opt-whole');\r\n        const OPT_IGNORECASE = document.getElementById('opt-ignorecase');\r\n        const OPT_REGEXP = document.getElementById('opt-regexp');\r\n        const OPT_MARK = document.getElementById('opt-mark');\r\n\r\n        const CONFIG_BTN = document.getElementById('config-btn');\r\n\r\n        const SHOW_PREV_NEXT_MARK = document.getElementById('show-prev-next-mark');\r\n        const SHOW_TOGGLE_MARK = document.getElementById('show-toggle-mark');\r\n        const SHOW_PREV_NEXT_HISTORY = document.getElementById('show-prev-next-history');\r\n        const SHOW_HOIST_DEHOIST = document.getElementById('show-hoist-dehoist');\r\n        const SHOW_LAYOUT_ORIENTATION = document.getElementById('show-layout-orientation');\r\n        const SHOW_THEME_TOGGLE = document.getElementById('show-theme-toggle');\r\n        const SHOW_NODE_ICONS = document.getElementById('show-node-icons');\r\n        const SHOW_COLLAPSE_ALL = document.getElementById('show-collapse-all');\r\n\r\n        const MENU = document.getElementById('menu');\r\n        const TOAST = document.getElementById('toast');\r\n        const HTML_ELEMENT = document.documentElement;\r\n\r\n        // * Navigation helpers\r\n        function children(node) {\r\n            // Given a node, return a shallow copy of its children array or an empty array.\r\n            return node && node.children ? node.children.slice() : [];\r\n        }\r\n\r\n        function childIndex(node) {\r\n            // Given a node, return its index among its siblings (0 for first, 1 for second, etc).\r\n            const parent = node.parent;\r\n            if (parent) {\r\n                const siblings = children(parent);\r\n                return siblings.indexOf(node);\r\n            }\r\n            return 0; // Should not happen for valid nodes because the top nodes are in the #outline-pane div\r\n        };\r\n\r\n        function parents(node) {\r\n            // Given a node, return an array of its ancestor nodes, closest first.\r\n            const ancestors = [];\r\n            let current = node;\r\n            while (current) {\r\n                const parent = current.parent;\r\n                if (parent) {\r\n                    ancestors.push(parent);\r\n                }\r\n                current = parent;\r\n            }\r\n            return ancestors;\r\n        };\r\n\r\n        function isAncestorOf(possibleAncestor, descendant) {\r\n            // Return true if possibleAncestor is an ancestor of descendant.\r\n            let current = descendant.parent;\r\n            while (current) {\r\n                if (current === possibleAncestor) {\r\n                    return true;\r\n                }\r\n                current = current.parent;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function hasChildren(node) {\r\n            // Given a node, return true if it has children.\r\n            return node.children && node.children.length > 0;\r\n        }\r\n\r\n        function isExpanded(node) {\r\n            // Given a node, return true if it is expanded.\r\n            if (!node.parent) return true; // The root node is always considered expanded\r\n            return expanded.has(node);\r\n        }\r\n\r\n        function isDescendantOfHoistedNode(node) {\r\n            if (!node || hoistStack.length === 0) return false;\r\n\r\n            const hoistedNode = hoistStack[hoistStack.length - 1];\r\n            return hoistedNode === node || isAncestorOf(hoistedNode, node);\r\n        }\r\n\r\n        function isVisible(node) {\r\n            // Return True if node is visible in the outline.\r\n            if (!node.parent) return false; // Root node is not visible\r\n\r\n            // First check if the node is descendant of the hoisted node\r\n            if (hoistStack.length > 0 && !isDescendantOfHoistedNode(node)) {\r\n                return false;\r\n            }\r\n\r\n            // Then check if all ancestors are expanded\r\n            const ancestors = parents(node);\r\n            for (const ancestor of ancestors) {\r\n                if (!isExpanded(ancestor)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function hasBack(node) {\r\n            // Given a node, return true if it has a previous sibling.\r\n            const parent = node.parent;\r\n            if (parent) {\r\n                const siblings = children(parent);\r\n                const index = siblings.indexOf(node);\r\n                return index > 0;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function hasNext(node) {\r\n            // Given a node, return true if it has a next sibling.\r\n            const parent = node.parent;\r\n            if (parent) {\r\n                const siblings = children(parent);\r\n                const index = siblings.indexOf(node);\r\n                return index < siblings.length - 1;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function hasParent(node) {\r\n            // Given a node, return true if it has a parent. Except if that parent is the hidden root node.\r\n            return !!node.parent && !!node.parent.parent;\r\n        }\r\n\r\n        function hasThreadBack(node) {\r\n            // Much cheaper than computing the actual value.\r\n            return hasBack(node) || hasParent(node);\r\n        }\r\n\r\n        function moveToBack(node) {\r\n            // Given a node, return its previous sibling. If first, or no parent, return null.\r\n            const parent = node.parent;\r\n            if (parent) {\r\n                const siblings = children(parent);\r\n                const index = siblings.indexOf(node);\r\n                return index > 0 ? siblings[index - 1] : null;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function moveToFirstChild(node) {\r\n            // Given a node, return its first child if any. Else return null.\r\n            return hasChildren(node) ? node.children[0] : null;\r\n        }\r\n\r\n        function moveToLastChild(node) {\r\n            // Given a node, return its last child if any. Else return null.\r\n            return hasChildren(node) ? node.children[node.children.length - 1] : null;\r\n        }\r\n\r\n        function moveToLastNode(node) {\r\n            // Given a node, return the last node of its tree or itself if no children.\r\n            while (hasChildren(node)) {\r\n                node = moveToLastChild(node);\r\n            }\r\n            return node;\r\n        }\r\n\r\n        function moveToNext(node) {\r\n            // Given a node, return its next sibling. If already last, return null.\r\n            const parent = node.parent;\r\n            if (parent) {\r\n                const siblings = children(parent);\r\n                const index = siblings.indexOf(node);\r\n                return index < siblings.length - 1 ? siblings[index + 1] : null;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function moveToNodeAfterTree(node) {\r\n            // Given a node, return the node after the position's tree.\r\n            while (node) {\r\n                if (hasNext(node)) {\r\n                    node = moveToNext(node);\r\n                    break;\r\n                }\r\n                node = moveToParent(node);\r\n            }\r\n            return node;\r\n        }\r\n\r\n        function moveToParent(node) {\r\n            // Given a node, return its parent or null if no parent.\r\n            const parent = node.parent;\r\n            if (parent) {\r\n                return parent;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function moveToThreadBack(node) {\r\n            // Given a node, return the previous node in the outline.\r\n            if (hasBack(node)) {\r\n                node = moveToBack(node);\r\n                node = moveToLastNode(node);\r\n            } else {\r\n                node = moveToParent(node);\r\n            }\r\n            return node;\r\n        }\r\n\r\n        function moveToThreadNext(node) {\r\n            // Given a node, return the next node in the outline.\r\n            if (hasChildren(node)) {\r\n                node = moveToFirstChild(node);\r\n            } else if (hasNext(node)) {\r\n                node = moveToNext(node);\r\n            } else {\r\n                node = moveToParent(node);\r\n                while (node) {\r\n                    if (node && hasNext(node)) {\r\n                        node = moveToNext(node);\r\n                        break;\r\n                    }\r\n                    node = moveToParent(node);\r\n                }\r\n            }\r\n            return node;\r\n        };\r\n\r\n        function moveToVisBack(node) {\r\n            // Given a node, return the previous visible node in the outline.\r\n            while (node) {\r\n                // Short-circuit if possible.\r\n                const back = moveToBack(node);\r\n                if (back && hasChildren(back) && isExpanded(back))\r\n                    node = moveToThreadBack(node);\r\n                else if (back) {\r\n                    node = moveToBack(node);\r\n                } else {\r\n                    node = moveToParent(node);  // Same as p.moveToThreadBack()\r\n                }\r\n                if (node && isVisible(node)) {\r\n                    return node;\r\n                }\r\n            }\r\n            return node;\r\n        }\r\n\r\n        function moveToVisNext(node) {\r\n            // Given a node, return the next visible node in the outline.\r\n            while (node) {\r\n                if (hasChildren(node)) {\r\n                    if (isExpanded(node)) {\r\n                        node = moveToFirstChild(node);\r\n                    } else {\r\n                        node = moveToNodeAfterTree(node);\r\n                    }\r\n                } else if (hasNext(node)) {\r\n                    node = moveToNext(node);\r\n                } else {\r\n                    node = moveToThreadNext(node);\r\n                }\r\n                if (node && isVisible(node)) {\r\n                    return node;\r\n                }\r\n            }\r\n        };\r\n\r\n        // * Navigation actions\r\n        function hoistNode() {\r\n            if (!selectedNode) return;\r\n\r\n            // If selected node is already hoisted: no-op (Even if button should be disabled in that case)\r\n            if (hoistStack.length > 0 && hoistStack[hoistStack.length - 1] === selectedNode) return;\r\n\r\n            if (!selectedNode.parent) return; // root node (though it should never be selected anyway)\r\n\r\n            hoistStack.push(selectedNode);\r\n            if (hasChildren(selectedNode) && !isExpanded(selectedNode)) {\r\n                expanded.add(selectedNode);\r\n                selectedNode.toggled = true; // Mark as toggled\r\n            }\r\n            updateHoistButtonStates();\r\n            updateContextMenuState(); // Node was already selected so no need to reupdate based on hoist\r\n            flatRows = flattenTree(getCurrentRoot(), 0, false);\r\n            renderTree();\r\n        }\r\n\r\n        function dehoistNode() {\r\n            if (hoistStack.length === 0) return;\r\n            const previousHoist = hoistStack.pop();\r\n            selectAndOrToggleAndRedraw(previousHoist);\r\n            updateHoistButtonStates();\r\n        }\r\n\r\n        function expandNodeAndGoToFirstChild() {\r\n            // If the presently selected node has children, expand it if needed and go to the first child.\r\n            let node = selectedNode;\r\n            if (hasChildren(node)) {\r\n                if (!isExpanded(node)) {\r\n                    expanded.add(node);\r\n                    node.toggled = true; // Mark as toggled\r\n                }\r\n                node = moveToFirstChild(node);\r\n                selectAndOrToggleAndRedraw(node);\r\n            }\r\n        }\r\n\r\n        function contractNodeOrGoToParent() {\r\n            // If the presently selected node is expanded, collapse it. Otherwise go to the parent.\r\n            let node = selectedNode;\r\n            if (hasChildren(node) && isExpanded(node)) {\r\n                selectAndOrToggleAndRedraw(null, node);\r\n            } else if (hasParent(node)) {\r\n                const parent = moveToParent(node);\r\n                if (isVisible(parent)) {\r\n                    // Contract all children first\r\n                    for (const child of children(parent)) {\r\n                        if (isExpanded(child)) {\r\n                            expanded.delete(child);\r\n                            child.toggled = true; // Mark as toggled\r\n                        }\r\n                    }\r\n                    selectAndOrToggleAndRedraw(parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        function selectVisBack() {\r\n            // Select the visible node preceding the presently selected node.\r\n            let node = selectedNode;\r\n            if (moveToVisBack(node)) {\r\n                node = moveToVisBack(node);\r\n                selectAndOrToggleAndRedraw(node);\r\n            }\r\n        }\r\n\r\n        function selectVisNext() {\r\n            // Select the visible node following the presently selected node.\r\n            let node = selectedNode;\r\n            if (moveToVisNext(node)) {\r\n                node = moveToVisNext(node);\r\n                selectAndOrToggleAndRedraw(node);\r\n            }\r\n        }\r\n\r\n        function gotoFirstSiblingOrParent() {\r\n            // Select the first sibling of the presently selected node, or its parent if already first.\r\n            let node = selectedNode;\r\n            const currentRoot = getCurrentRoot();\r\n            if (hasBack(node)) {\r\n                let firstVisibleSibling = null;\r\n                let current = node;\r\n                while (hasBack(current)) {\r\n                    let prev = moveToBack(current);\r\n                    if (isVisible(prev)) {\r\n                        firstVisibleSibling = prev;\r\n                        current = prev;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                if (firstVisibleSibling) {\r\n                    node = firstVisibleSibling;\r\n                }\r\n            } else if (hasParent(node) && node !== currentRoot) {\r\n                const parent = moveToParent(node);\r\n                if (parent === currentRoot || isDescendantOfHoistedNode(parent)) {\r\n                    node = parent;\r\n                }\r\n            }\r\n            selectAndOrToggleAndRedraw(node);\r\n        };\r\n\r\n        function gotoLastSiblingOrVisNext() {\r\n            // Select the last sibling of the presently selected node, or the next visible node if already last.\r\n            let node = selectedNode;\r\n            const currentRoot = getCurrentRoot();\r\n            if (hasNext(node)) {\r\n                let lastVisibleSibling = null;\r\n                let current = node;\r\n                while (hasNext(current)) {\r\n                    let next = moveToNext(current);\r\n                    if (isVisible(next)) {\r\n                        lastVisibleSibling = next;\r\n                        current = next;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                if (lastVisibleSibling) {\r\n                    node = lastVisibleSibling;\r\n                }\r\n            } else if (moveToVisNext(node)) {\r\n                node = moveToVisNext(node);\r\n            }\r\n            if (node) selectAndOrToggleAndRedraw(node);\r\n        };\r\n\r\n\r\n        function gotoFirstVisibleNode() {\r\n            // Get the current root (could be hoisted node or hidden root)\r\n            const currentRoot = getCurrentRoot();\r\n\r\n            // If we're hoisted, the first visible node could be the hoisted node itself\r\n            if (hoistStack.length > 0) {\r\n                selectAndOrToggleAndRedraw(currentRoot);\r\n                return;\r\n            }\r\n\r\n            // Otherwise, select the first child of the root node\r\n            const firstNode = moveToFirstChild(currentRoot);\r\n            if (firstNode) {\r\n                selectAndOrToggleAndRedraw(firstNode);\r\n            }\r\n        };\r\n\r\n        function gotoLastVisibleNode() {\r\n            // Select the last visible node in the outline.\r\n            let node = selectedNode;\r\n            while (node) {\r\n                const next = moveToVisNext(node);\r\n                if (next && isVisible(next)) {\r\n                    node = next;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            if (node) selectAndOrToggleAndRedraw(node);\r\n        };\r\n\r\n        function collapseAll() {\r\n            // Collapse all nodes in visible outline and select the proper top-level node\r\n            const currentRoot = getCurrentRoot();\r\n            if (currentRoot === tree) {\r\n                expanded.clear();\r\n            } else {\r\n                const nodesToRemove = [];\r\n                expanded.forEach(node => {\r\n                    if (node === currentRoot || isAncestorOf(currentRoot, node)) {\r\n                        nodesToRemove.push(node);\r\n                    }\r\n                });\r\n                nodesToRemove.forEach(node => expanded.delete(node));\r\n            }\r\n            if (hoistStack.length > 0) {\r\n                selectAndOrToggleAndRedraw(currentRoot);\r\n            } else {\r\n                let node = selectedNode;\r\n                // If currently selected node is a descendant of a top-level node, find that top-level node\r\n                while (node && hasParent(node) && node.parent !== tree) {\r\n                    node = moveToParent(node);\r\n                }\r\n                if (node) selectAndOrToggleAndRedraw(node);\r\n            }\r\n        };\r\n\r\n        function toggleSelected() {\r\n            if (selectedNode && selectedNode.children && selectedNode.children.length > 0) {\r\n                selectAndOrToggleAndRedraw(null, selectedNode);\r\n            }\r\n        }\r\n\r\n        function toggleMark(node) {\r\n            if (!node) return;\r\n            const gnx = node.gnx;\r\n            if (marked.has(gnx)) {\r\n                marked.delete(gnx);\r\n                if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) & ~2; // Clear marked bit\r\n            } else {\r\n                marked.add(gnx);\r\n                if (data[gnx]) data[gnx].icon = (data[gnx].icon || 0) | 2; // Set marked bit\r\n            }\r\n            updateMarkedButtonStates();\r\n            updateButtonVisibility();\r\n\r\n            // Only need to redraw the affected node if visible, no need to re-flatten because structure didn't change\r\n            if (isVisible(node)) {\r\n                renderTree();\r\n            }\r\n        }\r\n\r\n        function toggleMarkCurrentNode() {\r\n            if (selectedNode) {\r\n                toggleMark(selectedNode);\r\n            }\r\n        }\r\n\r\n        function gotoNextMarkedNode() {\r\n            if (!selectedNode || marked.size === 0) return;\r\n\r\n            const currentIndex = allNodesInOrder.findIndex(node => node === selectedNode);\r\n            if (currentIndex === -1) return; // Should never happen\r\n\r\n            let foundMarked = false;\r\n            for (let i = 1; i <= allNodesInOrder.length; i++) {\r\n                const nextIndex = (currentIndex + i) % allNodesInOrder.length; // Wrap around\r\n                const node = allNodesInOrder[nextIndex];\r\n\r\n                if (node === selectedNode) continue;\r\n\r\n                if (marked.has(node.gnx)) {\r\n                    selectAndOrToggleAndRedraw(node);\r\n                    foundMarked = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!foundMarked) {\r\n                if (marked.size === 1 && marked.has(selectedNode.gnx)) {\r\n                    showToast(\"Only one marked node.\");\r\n                } else {\r\n                    showToast(\"No other marked nodes found.\");\r\n                }\r\n            }\r\n        }\r\n\r\n        function gotoPrevMarkedNode() {\r\n            if (!selectedNode || marked.size === 0) return;\r\n\r\n            const currentIndex = allNodesInOrder.findIndex(node => node === selectedNode);\r\n            if (currentIndex === -1) return; // Should never happen\r\n\r\n            let foundMarked = false;\r\n            for (let i = 1; i <= allNodesInOrder.length; i++) {\r\n                const prevIndex = (currentIndex - i + allNodesInOrder.length) % allNodesInOrder.length; // Wrap around\r\n                const node = allNodesInOrder[prevIndex];\r\n\r\n                if (node === selectedNode) continue;\r\n\r\n                if (marked.has(node.gnx)) {\r\n                    selectAndOrToggleAndRedraw(node);\r\n                    foundMarked = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!foundMarked) {\r\n                if (marked.size === 1 && marked.has(selectedNode.gnx)) {\r\n                    showToast(\"Only one marked node.\");\r\n                } else {\r\n                    showToast(\"No other marked nodes found.\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // * Button states\r\n        function updateMarkedButtonStates() {\r\n            const hasMarkedNodes = marked.size > 0;\r\n            NEXT_MARKED_BTN.disabled = !hasMarkedNodes;\r\n            PREV_MARKED_BTN.disabled = !hasMarkedNodes;\r\n        }\r\n\r\n        function updateHoistButtonStates() {\r\n            const isCurrentlyHoisted = hoistStack.length > 0 && hoistStack[hoistStack.length - 1] === selectedNode;\r\n            DEHOIST_BTN.disabled = hoistStack.length === 0;\r\n            HOIST_BTN.disabled = !selectedNode || !hasChildren(selectedNode) || isCurrentlyHoisted;\r\n        }\r\n\r\n        function updateHistoryButtonStates() {\r\n            PREV_BTN.disabled = currentHistoryIndex <= 0;\r\n            NEXT_BTN.disabled = currentHistoryIndex >= navigationHistory.length - 1 || navigationHistory.length === 0;\r\n        }\r\n\r\n        function updateContextMenuState() {\r\n            const hasSelectedNode = !!selectedNode;\r\n            const isCurrentlyHoisted = hoistStack.length > 0 && hasSelectedNode && hoistStack[hoistStack.length - 1] === selectedNode;\r\n            toggleButtonVisibility(ACTION_MARK, undefined, hasSelectedNode && !marked.has(selectedNode.gnx));\r\n            toggleButtonVisibility(ACTION_UNMARK, undefined, hasSelectedNode && marked.has(selectedNode.gnx));\r\n            toggleButtonVisibility(ACTION_HOIST, undefined, hasSelectedNode && hasChildren(selectedNode) && !isCurrentlyHoisted);\r\n            toggleButtonVisibility(ACTION_DEHOIST, undefined, hoistStack.length > 0); // only check hoist stack length\r\n        }\r\n\r\n        function toggleConfiguration() {\r\n            if (HTML_ELEMENT.getAttribute('data-show-config') === 'true') {\r\n                HTML_ELEMENT.setAttribute('data-show-config', 'false');\r\n                CONFIG_BTN.innerHTML = '⚙️';\r\n                CONFIG_BTN.setAttribute('title', 'Configuration');\r\n                CONFIG_BTN.setAttribute('aria-label', 'Configuration');\r\n            } else {\r\n                HTML_ELEMENT.setAttribute('data-show-config', 'true');\r\n                CONFIG_BTN.innerHTML = '✔️';\r\n                CONFIG_BTN.setAttribute('title', 'Back to Find');\r\n                CONFIG_BTN.setAttribute('aria-label', 'Back to Find');\r\n            }\r\n        }\r\n\r\n        // * History\r\n        function addToHistory(node) {\r\n            if (navigationHistory.length > 0 &&\r\n                navigationHistory[currentHistoryIndex] === node) {\r\n                return; // Already the current node, do nothing\r\n            }\r\n            // If we're not at the end, truncate the forward history\r\n            if (currentHistoryIndex < navigationHistory.length - 1) {\r\n                navigationHistory.splice(currentHistoryIndex + 1);\r\n            }\r\n            navigationHistory.push(node); // Add the new node to history\r\n            currentHistoryIndex = navigationHistory.length - 1;\r\n            updateHistoryButtonStates();\r\n        }\r\n\r\n        function previousHistory() {\r\n            if (currentHistoryIndex > 0) {\r\n                currentHistoryIndex--;\r\n                const node = navigationHistory[currentHistoryIndex];\r\n                selectAndOrToggleAndRedraw(node); // Goto node without adding to history\r\n                updateHistoryButtonStates();\r\n            }\r\n        }\r\n\r\n        function nextHistory() {\r\n            if (currentHistoryIndex < navigationHistory.length - 1) {\r\n                currentHistoryIndex++;\r\n                const node = navigationHistory[currentHistoryIndex];\r\n                selectAndOrToggleAndRedraw(node); // Goto node without adding to history\r\n                updateHistoryButtonStates();\r\n            }\r\n        }\r\n\r\n        // * Rendering helpers\r\n        function getCurrentRoot() {\r\n            // Return the current top of the hoist stack or the main tree root\r\n            return hoistStack.length > 0 ? hoistStack[hoistStack.length - 1] : tree;\r\n        }\r\n\r\n        function flattenTree(node, depth = 0, isRoot = true) {\r\n            // This only flattens the tree structure into an array of rows for rendering.\r\n            // It check for expansion state to include children as needed because only expanded nodes' children are visible.\r\n            // The isRoot parameter indicates if this node is the hidden root node (not visible).\r\n\r\n            let rows = [];\r\n\r\n            // Only add non-root nodes to the rows\r\n            if (!isRoot) {\r\n                rows.push({\r\n                    label: data[node.gnx].headString,\r\n                    depth,\r\n                    toggled: node.toggled || false, // Will make it render with toggled class\r\n                    hasChildren: !!node.children && node.children.length > 0,\r\n                    isExpanded: isExpanded(node),\r\n                    node\r\n                });\r\n            }\r\n            if (node.toggled) {\r\n                node.toggled = false; // Reset because it should not persist\r\n            }\r\n\r\n            if (isExpanded(node) && node.children) {\r\n                for (const child of node.children) {\r\n                    // Root node's children appear at depth 0\r\n                    const childDepth = isRoot ? 0 : depth + 1;\r\n                    rows.push(...flattenTree(child, childDepth, false));\r\n                }\r\n            }\r\n\r\n            return rows;\r\n        }\r\n\r\n        function selectAndOrToggleAndRedraw(newSelectedNode = null, nodeToToggle = null) {\r\n            // Handle toggling if requested\r\n            if (nodeToToggle) {\r\n                if (isExpanded(nodeToToggle)) {\r\n                    expanded.delete(nodeToToggle);\r\n                } else {\r\n                    expanded.add(nodeToToggle);\r\n                }\r\n                nodeToToggle.toggled = true; // Mark as toggled\r\n            }\r\n\r\n            const isNew = newSelectedNode && newSelectedNode !== selectedNode;\r\n\r\n            // Handle selection if requested\r\n            if (isNew) {\r\n                let hoistTop = getCurrentRoot();\r\n\r\n                // While the top of hoist stack is not an ancestor of the new selected node, pop it\r\n                while (newSelectedNode !== hoistTop && hoistStack.length > 0 && !isAncestorOf(hoistTop, newSelectedNode)) {\r\n                    hoistStack.pop();\r\n                    hoistTop = getCurrentRoot();\r\n                }\r\n\r\n                // Ensure all parent nodes are expanded so the selected node is visible\r\n                let currentNode = newSelectedNode;\r\n                while (currentNode && currentNode.parent && currentNode !== hoistTop) {\r\n                    // Skip the hidden root node since it's always expanded (When hoist is implemented, stop at hoist root)\r\n                    if (currentNode.parent.parent) {\r\n                        expanded.add(currentNode.parent);\r\n                    }\r\n                    currentNode = currentNode.parent;\r\n                }\r\n\r\n                selectedNode = newSelectedNode;\r\n                addToHistory(newSelectedNode);\r\n                updateButtonVisibility();\r\n                updateHoistButtonStates();\r\n                updateContextMenuState();\r\n            }\r\n\r\n            // Only rebuild and redraw once\r\n            const currentRoot = getCurrentRoot();\r\n            const isHoisted = hoistStack.length > 0;\r\n\r\n            // If hoisted, pass isRoot=false to make the hoisted node visible\r\n            // If not hoisted, use the hidden root with isRoot=true\r\n            flatRows = flattenTree(currentRoot, 0, !isHoisted);\r\n            renderTree();\r\n\r\n            // Update body pane if selection changed (selectedNode cannot be null here because of isNew check)\r\n            if (isNew) {\r\n                if (newSelectedNode && data[newSelectedNode.gnx]) {\r\n                    setBody(newSelectedNode);\r\n                } else {\r\n                    BODY_PANE.textContent = \"\";\r\n                }\r\n            }\r\n            scrollSelectedNodeIntoView();\r\n            updateCollapseAllPosition(); // In case the height made the scrollbar appear/disappear\r\n        }\r\n\r\n        function setBody(node) {\r\n            // Look for a line in the text starting with \"@wrap\" or \"@nowrap\",\r\n            // if not found, check the parent of node recursively.\r\n            // Note: wrap is default so only need to check for nowrap\r\n            let currentNode = node;\r\n            let nowrapFound = false;\r\n            while (currentNode.parent) { // Make sure to stop at the hidden root node\r\n                const body = data[currentNode.gnx].bodyString || \"\";\r\n                const wrapMatch = body.match(/^\\s*@wrap\\s*$/m);\r\n                const nowrapMatch = body.match(/^\\s*@nowrap\\s*$/m);\r\n                if (wrapMatch) {\r\n                    break;  // Stop searching if @wrap (default) is found\r\n                }\r\n                if (nowrapMatch) {\r\n                    nowrapFound = true;\r\n                    break;  // Stop searching if @nowrap is found\r\n                }\r\n                currentNode = currentNode.parent;\r\n            }\r\n            if (nowrapFound) {\r\n                BODY_PANE.style.whiteSpace = \"pre\"; // No wrapping\r\n            } else {\r\n                BODY_PANE.style.whiteSpace = \"pre-wrap\"; // Wrap text\r\n            }\r\n            let text = data[node.gnx].bodyString || \"\";\r\n\r\n            // Escape HTML entities first to preserve literal characters\r\n            text = text.replace(/&/g, '&amp;')\r\n                .replace(/</g, '&lt;')\r\n                .replace(/>/g, '&gt;')\r\n                .replace(/\"/g, '&quot;')\r\n                .replace(/'/g, '&#039;');\r\n\r\n            // Then replace URLs with actual clickable links\r\n            text = text.replace(urlRegex, url => {\r\n                return `<a href=\"${url}\" target=\"_blank\" contenteditable=\"false\" rel=\"noopener noreferrer\">${url}</a>`;\r\n            });\r\n            BODY_PANE.innerHTML = text;\r\n        }\r\n\r\n        function scrollSelectedNodeIntoView() {\r\n            if (!selectedNode || !flatRows) return; // Not initialized yet\r\n\r\n            const selectedIndex = flatRows.findIndex(row => row.node === selectedNode);\r\n            if (selectedIndex === -1) return; // Not found (shouldn't happen)\r\n            const nodePosition = selectedIndex * ROW_HEIGHT;\r\n\r\n            const scrollTop = OUTLINE_PANE.scrollTop;\r\n            const viewportHeight = OUTLINE_PANE.clientHeight;\r\n\r\n            if (nodePosition < scrollTop) {\r\n                OUTLINE_PANE.scrollTop = nodePosition;\r\n            } else if (nodePosition + ROW_HEIGHT > scrollTop + viewportHeight) {\r\n                OUTLINE_PANE.scrollTop = nodePosition - viewportHeight + ROW_HEIGHT;\r\n            }\r\n        }\r\n\r\n        function renderTree() {\r\n            if (!flatRows) return; // Not initialized yet\r\n\r\n            // Render visible rows only\r\n            const scrollTop = OUTLINE_PANE.scrollTop;\r\n            const viewportHeight = OUTLINE_PANE.clientHeight;\r\n            const viewportWidth = OUTLINE_PANE.clientWidth;\r\n\r\n            const startIndex = Math.floor(scrollTop / ROW_HEIGHT);\r\n            const visibleCount = Math.ceil(viewportHeight / ROW_HEIGHT) + 1;\r\n            const endIndex = Math.min(flatRows.length, startIndex + visibleCount);\r\n            let leftOffset = LEFT_OFFSET;\r\n\r\n            // If all nodes have no children, remove the left offset\r\n            if (flatRows.every(row => !row.hasChildren)) {\r\n                leftOffset = 0;\r\n            }\r\n\r\n            SPACER.innerHTML = \"\";\r\n            SPACER.style.height = flatRows.length * ROW_HEIGHT + \"px\";\r\n\r\n            let selectedRadioValue = ''; // Falsy for now\r\n            const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\r\n            if (selectedRadio) {\r\n                selectedRadioValue = selectedRadio.value;\r\n            }\r\n\r\n            const searchSuboutline = selectedRadioValue === 'suboutline' && initialFindNode; // Will contain the node or null\r\n            const searchNodeOnly = selectedRadioValue === 'node'; // selected node only\r\n\r\n            for (let i = startIndex; i < endIndex; i++) {\r\n                const row = flatRows[i];\r\n                const div = document.createElement(\"div\");\r\n                div.className = \"node\";\r\n                if (row.label) {\r\n                    div.title = row.label;\r\n                }\r\n\r\n                if (row.node === selectedNode) {\r\n                    div.classList.add(\"selected\");\r\n                } else if (selectedNode && isAncestorOf(row.node, selectedNode)) {\r\n                    div.classList.add(\"ancestor\");\r\n                }\r\n\r\n                if (searchNodeOnly && row.node === selectedNode) {\r\n                    div.classList.add(\"initial-find\");\r\n                }\r\n\r\n                if (searchSuboutline && (row.node === searchSuboutline || isAncestorOf(searchSuboutline, row.node))) {\r\n                    div.classList.add(\"initial-find\");\r\n                }\r\n\r\n                div.style.top = (i * ROW_HEIGHT) + \"px\";\r\n                div.style.height = ROW_HEIGHT + \"px\";\r\n\r\n                const leftPosition = (row.depth * 20) + leftOffset;\r\n                div.style.left = leftPosition + \"px\";\r\n                div.style.width = (viewportWidth - leftPosition) + \"px\";\r\n\r\n                const caret = document.createElement(\"span\");\r\n                caret.className = row.toggled ? \"caret toggled\" : \"caret\";\r\n\r\n                row.toggled = false; // Reset toggled state after rendering\r\n\r\n                if (row.hasChildren) {\r\n                    caret.setAttribute(\"data-expanded\", row.isExpanded ? \"true\" : \"false\");\r\n                }\r\n                div.appendChild(caret);\r\n\r\n                const labelSpan = document.createElement(\"span\");\r\n                labelSpan.className = \"node-text\";\r\n\r\n                // If dark mode, invert the icons' 4 bit to swap dirty borders inverted\r\n                if (currentTheme === 'dark') {\r\n                    let invertedIcon = data[row.node.gnx].icon ^ 8; // Toggle the 4 bit\r\n                    labelSpan.classList.add(\"icon\" + invertedIcon);\r\n                } else {\r\n                    labelSpan.classList.add(\"icon\" + (data[row.node.gnx].icon || 0));\r\n                }\r\n\r\n                labelSpan.textContent = row.label;\r\n                if (row.node === selectedNode) {\r\n                    selectedLabelElement = labelSpan;\r\n                }\r\n\r\n                div.appendChild(labelSpan);\r\n                SPACER.appendChild(div);\r\n            }\r\n        }\r\n\r\n        function throttle(func, limit) {\r\n            let lastCall = 0;\r\n            let timeout;\r\n\r\n            return function (...args) {\r\n                const now = Date.now();\r\n                if (timeout) {\r\n                    clearTimeout(timeout);\r\n                }\r\n                if (now - lastCall >= limit) {\r\n                    lastCall = now;\r\n                    func.apply(this, args);\r\n                } else {\r\n                    timeout = setTimeout(() => {\r\n                        lastCall = Date.now();\r\n                        func.apply(this, args);\r\n                    }, limit - (now - lastCall));\r\n                }\r\n            };\r\n        }\r\n\r\n        function showToast(message, duration = 2000) {\r\n            if (!TOAST) return;\r\n            TOAST.textContent = message;\r\n            TOAST.hidden = false;\r\n            // Force reflow so the transition always runs when toggling\r\n            void TOAST.offsetWidth;\r\n            TOAST.classList.add('show');\r\n            if (__toastTimer) {\r\n                clearTimeout(__toastTimer);\r\n            }\r\n            __toastTimer = setTimeout(() => {\r\n                TOAST.classList.remove('show');\r\n                setTimeout(() => { TOAST.hidden = true; }, 220);\r\n                __toastTimer = null;\r\n            }, duration);\r\n        }\r\n\r\n        function safeLocalStorageGet(key) {\r\n            try {\r\n                return localStorage.getItem(key);\r\n            } catch (e) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        function safeLocalStorageSet(key, value) {\r\n            try {\r\n                localStorage.setItem(key, value);\r\n            } catch (e) {\r\n                // ignore\r\n            }\r\n        }\r\n\r\n        function preventDefault(e) {\r\n            e.preventDefault(); // Utility function used in setupBodyPaneHandlers\r\n        }\r\n\r\n        function updateProportion() {\r\n            if (currentLayout === 'vertical') {\r\n                mainRatio = OUTLINE_FIND_CONTAINER.offsetWidth / window.innerWidth;\r\n            } else {\r\n                mainRatio = OUTLINE_FIND_CONTAINER.offsetHeight / window.innerHeight;\r\n            }\r\n        }\r\n\r\n        function updateOutlineContainerSize() {\r\n            if (currentLayout === 'vertical') {\r\n                let newWidth = window.innerWidth * mainRatio;\r\n                if (newWidth < minWidth) {\r\n                    newWidth = minWidth;\r\n                }\r\n                OUTLINE_FIND_CONTAINER.style.width = `${newWidth}px`;\r\n                OUTLINE_FIND_CONTAINER.style.height = '100%';\r\n                CONFIG_BTN.style.inset = `auto auto 7px ${newWidth - 33}px`;\r\n            } else {\r\n                let newHeight = window.innerHeight * mainRatio;\r\n                if (newHeight < minWidth) {\r\n                    newHeight = minWidth;\r\n                }\r\n                OUTLINE_FIND_CONTAINER.style.height = `${newHeight}px`;\r\n                OUTLINE_FIND_CONTAINER.style.width = '100%';\r\n                CONFIG_BTN.style.inset = `${newHeight - 33}px 7px auto auto`;\r\n            }\r\n        }\r\n\r\n        const handleDrag = throttle(function (e) {\r\n            if (currentLayout === 'vertical') {\r\n                let clientX = e.clientX;\r\n                if (e.touches) {\r\n                    clientX = e.touches[0].clientX;\r\n                }\r\n                const newWidth = clientX;\r\n                if (newWidth >= minWidth) {\r\n                    OUTLINE_FIND_CONTAINER.style.width = (newWidth - 3) + 'px';\r\n                } else {\r\n                    OUTLINE_FIND_CONTAINER.style.width = (minWidth - 3) + 'px';\r\n                }\r\n                CONFIG_BTN.style.inset = `auto auto 7px ${newWidth - 33}px`;\r\n            } else {\r\n                let clientY = e.clientY;\r\n                if (e.touches) {\r\n                    clientY = e.touches[0].clientY;\r\n                }\r\n                const newHeight = clientY;\r\n                if (newHeight >= minWidth) {\r\n                    OUTLINE_FIND_CONTAINER.style.height = (newHeight - 3) + 'px';\r\n                } else {\r\n                    OUTLINE_FIND_CONTAINER.style.height = (minWidth - 3) + 'px';\r\n                }\r\n                CONFIG_BTN.style.inset = `${newHeight - 33}px 7px auto auto`;\r\n            }\r\n            positionCrossDragger();\r\n            renderTree();\r\n            updateCollapseAllPosition();\r\n        }, 33);\r\n\r\n        function startDrag(e) {\r\n            isDragging = true;\r\n            document.body.classList.add('dragging-main');\r\n            e.preventDefault();\r\n            document.addEventListener('mousemove', handleDrag);\r\n            document.addEventListener('mouseup', stopDrag);\r\n            document.addEventListener('touchmove', handleDrag, { passive: false });\r\n            document.addEventListener('touchend', stopDrag);\r\n        }\r\n\r\n        function stopDrag() {\r\n            if (isDragging) {\r\n                isDragging = false;\r\n                document.body.classList.remove('dragging-main');\r\n                document.removeEventListener('mousemove', handleDrag);\r\n                document.removeEventListener('mouseup', stopDrag);\r\n                document.removeEventListener('touchmove', handleDrag);\r\n                document.removeEventListener('touchend', stopDrag);\r\n                updateProportion();\r\n                renderTree();\r\n            }\r\n        }\r\n\r\n        function updateSecondaryProportion() {\r\n            if (currentLayout === 'vertical') {\r\n                secondaryRatio = (OUTLINE_PANE.offsetHeight - 6) / OUTLINE_FIND_CONTAINER.offsetHeight;\r\n            } else {\r\n                secondaryRatio = OUTLINE_PANE.offsetWidth / OUTLINE_FIND_CONTAINER.offsetWidth;\r\n            }\r\n        }\r\n\r\n        function updateOutlinePaneSize() {\r\n            if (currentLayout === 'vertical') {\r\n                const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;\r\n                let newHeight = containerHeight * secondaryRatio;\r\n                if (newHeight < minHeight) {\r\n                    newHeight = minHeight; // Respect minimum heights\r\n                } else if (newHeight > containerHeight - minHeight) {\r\n                    newHeight = containerHeight - minHeight;\r\n                }\r\n                OUTLINE_PANE.style.flex = `0 0 ${newHeight}px`;\r\n            } else {\r\n                const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;\r\n                let newWidth = containerWidth * secondaryRatio;\r\n                if (newWidth < minHeight) {\r\n                    newWidth = minHeight; // Respect minimum widths\r\n                } else if (newWidth > containerWidth - minHeight) {\r\n                    newWidth = containerWidth - minHeight;\r\n                }\r\n                OUTLINE_PANE.style.flex = `0 0 ${newWidth}px`;\r\n            }\r\n            FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\r\n            updateCollapseAllPosition();\r\n        }\r\n\r\n        function updateCollapseAllPosition() {\r\n            COLLAPSE_ALL_BTN.style.inset = `6px auto auto ${OUTLINE_PANE.clientWidth - 18}px`;\r\n        }\r\n\r\n        const handleSecondaryDrag = throttle(function (e) {\r\n            if (currentLayout === 'vertical') {\r\n                let clientY = e.clientY;\r\n                if (e.touches) {\r\n                    clientY = e.touches[0].clientY;\r\n                }\r\n                const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();\r\n                const relativeY = clientY - containerRect.top;\r\n                const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;\r\n                if (relativeY >= minHeight && relativeY <= containerHeight - minHeight) {\r\n                    OUTLINE_PANE.style.flex = `0 0 ${relativeY - 8}px`;\r\n                    FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\r\n                }\r\n            } else {\r\n                let clientX = e.clientX;\r\n                if (e.touches) {\r\n                    clientX = e.touches[0].clientX;\r\n                }\r\n                const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();\r\n                const relativeX = clientX - containerRect.left;\r\n                const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;\r\n                if (relativeX >= minHeight && relativeX <= containerWidth - minHeight) {\r\n                    OUTLINE_PANE.style.flex = `0 0 ${relativeX - 3}px`;\r\n                    FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\r\n                }\r\n            }\r\n            positionCrossDragger();\r\n            renderTree();\r\n            updateCollapseAllPosition();\r\n        }, 33);\r\n\r\n        function startSecondaryDrag(e) {\r\n            secondaryIsDragging = true;\r\n            document.body.classList.add('dragging-secondary');\r\n            e.preventDefault();\r\n            document.addEventListener('mousemove', handleSecondaryDrag);\r\n            document.addEventListener('mouseup', stopSecondaryDrag);\r\n            document.addEventListener('touchmove', handleSecondaryDrag, { passive: false });\r\n            document.addEventListener('touchend', stopSecondaryDrag);\r\n        }\r\n\r\n        function stopSecondaryDrag() {\r\n            if (secondaryIsDragging) {\r\n                secondaryIsDragging = false;\r\n                document.body.classList.remove('dragging-secondary');\r\n                document.removeEventListener('mousemove', handleSecondaryDrag);\r\n                document.removeEventListener('mouseup', stopSecondaryDrag);\r\n                document.removeEventListener('touchmove', handleSecondaryDrag);\r\n                document.removeEventListener('touchend', stopSecondaryDrag);\r\n                updateSecondaryProportion();\r\n                renderTree();\r\n            }\r\n        }\r\n\r\n        const handleCrossDrag = throttle((e) => {\r\n            let clientX = e.clientX;\r\n            let clientY = e.clientY;\r\n            if (e.touches) {\r\n                clientX = e.touches[0].clientX;\r\n                clientY = e.touches[0].clientY;\r\n            }\r\n\r\n            if (currentLayout === 'vertical') {\r\n                // Handle cross drag when in vertical layout\r\n\r\n                // do main first as per handleDrag\r\n                const newWidth = clientX;\r\n                if (newWidth >= minWidth) {\r\n                    OUTLINE_FIND_CONTAINER.style.width = (newWidth - 3) + 'px';\r\n                } else {\r\n                    OUTLINE_FIND_CONTAINER.style.width = (minWidth - 3) + 'px';\r\n                }\r\n                // then secondary as per handleSecondaryDrag\r\n                const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();\r\n                const relativeY = clientY - containerRect.top;\r\n                const containerHeight = OUTLINE_FIND_CONTAINER.offsetHeight;\r\n                if (relativeY >= minHeight && relativeY <= containerHeight - minHeight) {\r\n                    OUTLINE_PANE.style.flex = `0 0 ${relativeY - 8}px`;\r\n                    FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\r\n                }\r\n            } else {\r\n                // Handle cross drag when in horizontal layout\r\n\r\n                // do main first as per handleDrag\r\n                const newHeight = clientY;\r\n                if (newHeight >= minWidth) {\r\n                    OUTLINE_FIND_CONTAINER.style.height = (newHeight - 3) + 'px';\r\n                } else {\r\n                    OUTLINE_FIND_CONTAINER.style.height = (minWidth - 3) + 'px';\r\n                }\r\n                // then secondary as per handleSecondaryDrag\r\n                const containerRect = OUTLINE_FIND_CONTAINER.getBoundingClientRect();\r\n                const relativeX = clientX - containerRect.left;\r\n                const containerWidth = OUTLINE_FIND_CONTAINER.offsetWidth;\r\n                if (relativeX >= minHeight && relativeX <= containerWidth - minHeight) {\r\n                    OUTLINE_PANE.style.flex = `0 0 ${relativeX - 3}px`;\r\n                    FIND_PANE.style.flex = '1 1 auto'; // Let it take the remaining space\r\n                }\r\n            }\r\n            positionCrossDragger();\r\n            renderTree();\r\n            updateCollapseAllPosition();\r\n        }, 33);\r\n\r\n        const startCrossDrag = (e) => {\r\n            crossIsDragging = true;\r\n            document.body.classList.add('dragging-cross');\r\n            e.preventDefault();\r\n            document.addEventListener('mousemove', handleCrossDrag);\r\n            document.addEventListener('mouseup', stopCrossDrag);\r\n            document.addEventListener('touchmove', handleCrossDrag, { passive: false });\r\n            document.addEventListener('touchend', stopCrossDrag);\r\n\r\n        }\r\n\r\n        const stopCrossDrag = () => {\r\n            if (crossIsDragging) {\r\n                crossIsDragging = false;\r\n                document.body.classList.remove('dragging-cross');\r\n                document.removeEventListener('mousemove', handleCrossDrag);\r\n                document.removeEventListener('mouseup', stopCrossDrag);\r\n                document.removeEventListener('touchmove', handleCrossDrag);\r\n                document.removeEventListener('touchend', stopCrossDrag);\r\n\r\n                updateProportion();\r\n                updateSecondaryProportion();\r\n\r\n                renderTree();\r\n            }\r\n        }\r\n\r\n        function positionCrossDragger() {\r\n            if (currentLayout === 'vertical') {\r\n                const outlineWidth = OUTLINE_FIND_CONTAINER.offsetWidth;\r\n                const paneHeight = OUTLINE_PANE.offsetHeight;\r\n                CROSS_RESIZER.style.top = (paneHeight) + 'px';\r\n                CROSS_RESIZER.style.left = (outlineWidth) + 'px';\r\n            } else {\r\n                const outlineHeight = OUTLINE_FIND_CONTAINER.offsetHeight;\r\n                const paneWidth = OUTLINE_PANE.offsetWidth;\r\n                CROSS_RESIZER.style.left = (paneWidth) + 'px';\r\n                CROSS_RESIZER.style.top = (outlineHeight) + 'px';\r\n            }\r\n\r\n        }\r\n\r\n\r\n        function updatePanelSizes() {\r\n            updateOutlineContainerSize();\r\n            updateOutlinePaneSize();\r\n            positionCrossDragger();\r\n        }\r\n\r\n        function applyTheme(theme) {\r\n            currentTheme = theme;\r\n            HTML_ELEMENT.setAttribute('data-theme', theme);\r\n            THEME_TOGGLE.title = theme === 'dark' ? 'Switch to light theme' : 'Switch to dark theme';\r\n            THEME_ICON.innerHTML = theme === 'dark' ? '🌙' : '☀️';\r\n        };\r\n\r\n        function applyLayout(layout) {\r\n            currentLayout = layout;\r\n            LAYOUT_TOGGLE.title = layout === 'vertical' ? 'Switch to horizontal layout' : 'Switch to vertical layout';\r\n            if (layout === 'horizontal') {\r\n                HTML_ELEMENT.setAttribute('data-layout', 'horizontal');\r\n            } else {\r\n                HTML_ELEMENT.setAttribute('data-layout', 'vertical');\r\n            }\r\n            updatePanelSizes(); // Proportions will have changed so we must update sizes\r\n            if (flatRows) {\r\n                renderTree();\r\n            }\r\n        };\r\n\r\n        // Setup and organize all event handlers\r\n        function setupEventHandlers() {\r\n            setupOutlinePaneHandlers();\r\n            setupBodyPaneHandlers();\r\n            setupResizerHandlers();\r\n            setupWindowHandlers();\r\n            setupButtonHandlers();\r\n            setupFindPaneHandlers();\r\n            setupConfigCheckboxes();\r\n        }\r\n\r\n        function setupOutlinePaneHandlers() {\r\n            OUTLINE_PANE.addEventListener(\"mousedown\", handleOutlinePaneMouseDown);\r\n            OUTLINE_PANE.addEventListener('click', handleOutlinePaneClick);\r\n            OUTLINE_PANE.addEventListener('dblclick', handleOutlinePaneDblClick);\r\n            OUTLINE_PANE.addEventListener('keydown', handleOutlinePaneKeyDown);\r\n            OUTLINE_PANE.addEventListener(\"scroll\", throttle(renderTree, 33));\r\n            OUTLINE_PANE.addEventListener(\"contextmenu\", handleContextMenu);\r\n            document.addEventListener(\"click\", () => {\r\n                MENU.style.display = \"none\";\r\n            });\r\n        }\r\n\r\n        function setupBodyPaneHandlers() {\r\n            BODY_PANE.addEventListener('keydown', handleBodyPaneKeyDown);\r\n            BODY_PANE.addEventListener(\"beforeinput\", preventDefault); // Block text changes\r\n            BODY_PANE.addEventListener(\"paste\", preventDefault); // Block text changes\r\n        }\r\n\r\n        function setupResizerHandlers() {\r\n            VERTICAL_RESIZER.addEventListener('mousedown', startDrag);\r\n            VERTICAL_RESIZER.addEventListener('touchstart', startDrag);\r\n            HORIZONTAL_RESIZER.addEventListener('mousedown', startSecondaryDrag);\r\n            HORIZONTAL_RESIZER.addEventListener('touchstart', startSecondaryDrag);\r\n            CROSS_RESIZER.addEventListener('mousedown', startCrossDrag);\r\n            CROSS_RESIZER.addEventListener('touchstart', startCrossDrag);\r\n        }\r\n\r\n        function setupWindowHandlers() {\r\n            window.addEventListener('resize', throttle(handleWindowResize, 33));\r\n            window.addEventListener('keydown', handleGlobalKeyDown);\r\n            window.addEventListener('beforeunload', saveAll);\r\n        }\r\n\r\n        function setupButtonHandlers() {\r\n            COLLAPSE_ALL_BTN.addEventListener('click', collapseAll);\r\n            THEME_TOGGLE.addEventListener('click', handleThemeToggleClick);\r\n            LAYOUT_TOGGLE.addEventListener('click', handleLayoutToggleClick);\r\n            HOIST_BTN.addEventListener('click', hoistNode);\r\n            DEHOIST_BTN.addEventListener('click', dehoistNode);\r\n            PREV_BTN.addEventListener('click', previousHistory);\r\n            NEXT_BTN.addEventListener('click', nextHistory);\r\n            TOGGLE_MARK_BTN.addEventListener('click', toggleMarkCurrentNode);\r\n            NEXT_MARKED_BTN.addEventListener('click', gotoNextMarkedNode);\r\n            PREV_MARKED_BTN.addEventListener('click', gotoPrevMarkedNode);\r\n            CONFIG_BTN.addEventListener('click', toggleConfiguration);\r\n\r\n            ACTION_MARK.addEventListener('click', toggleMarkCurrentNode);\r\n            ACTION_UNMARK.addEventListener('click', toggleMarkCurrentNode); // Same action\r\n            ACTION_HOIST.addEventListener('click', hoistNode);\r\n            ACTION_DEHOIST.addEventListener('click', dehoistNode);\r\n        }\r\n\r\n        function setupFindPaneHandlers() {\r\n            FIND_INPUT.addEventListener('keydown', function (e) {\r\n                if (e.key === 'Tab' && e.shiftKey) {\r\n                    e.preventDefault();\r\n                    OPT_BODY.focus();\r\n                }\r\n                if (e.key === 'Enter') {\r\n                    e.preventDefault();\r\n                    findNext();\r\n                }\r\n            });\r\n            OPT_BODY.addEventListener('keydown', function (e) {\r\n                if (e.key === 'Tab' && !e.shiftKey) {\r\n                    e.preventDefault();\r\n                    FIND_INPUT.focus();\r\n                }\r\n            });\r\n            const findScopeRadios = document.querySelectorAll('input[name=\"find-scope\"]');\r\n            findScopeRadios.forEach(radio => {\r\n                radio.addEventListener('change', function () {\r\n                    initialFindNode = null; // Reset initial find node when scope changes\r\n                    renderTree(); // Re-render to update node highlighting\r\n                });\r\n            });\r\n        }\r\n\r\n        function setupButtonFocusPrevention() {\r\n            const actionButtons = document.querySelectorAll('.action-button');\r\n            actionButtons.forEach(button => {\r\n                button.addEventListener('mousedown', (e) => {\r\n                    e.preventDefault();\r\n                });\r\n            });\r\n        }\r\n\r\n        function setupConfigCheckboxes() {\r\n            SHOW_PREV_NEXT_MARK.addEventListener('change', updateButtonVisibility);\r\n            SHOW_TOGGLE_MARK.addEventListener('change', updateButtonVisibility);\r\n            SHOW_PREV_NEXT_HISTORY.addEventListener('change', updateButtonVisibility);\r\n            SHOW_HOIST_DEHOIST.addEventListener('change', updateButtonVisibility);\r\n            SHOW_LAYOUT_ORIENTATION.addEventListener('change', updateButtonVisibility);\r\n            SHOW_THEME_TOGGLE.addEventListener('change', updateButtonVisibility);\r\n            SHOW_NODE_ICONS.addEventListener('change', updateNodeIcons);\r\n            SHOW_COLLAPSE_ALL.addEventListener('change', updateButtonVisibility);\r\n        }\r\n\r\n        function setupButtonContainerAutoHide() {\r\n            let hideTimeout;\r\n            function showButtons() {\r\n                BUTTON_CONTAINER.classList.remove('hidden');\r\n                clearTimeout(hideTimeout);\r\n            }\r\n\r\n            function hideButtons() {\r\n                hideTimeout = setTimeout(() => {\r\n                    BUTTON_CONTAINER.classList.add('hidden');\r\n                }, 1500);\r\n            }\r\n            TRIGGER_AREA.addEventListener('mouseenter', showButtons);\r\n            BUTTON_CONTAINER.addEventListener('mouseenter', showButtons);\r\n            TRIGGER_AREA.addEventListener('mouseleave', (e) => {\r\n                if (!BUTTON_CONTAINER.contains(e.relatedTarget)) {\r\n                    hideButtons();\r\n                }\r\n            });\r\n            BUTTON_CONTAINER.addEventListener('mouseleave', (e) => {\r\n                if (e.relatedTarget !== TRIGGER_AREA) {\r\n                    hideButtons();\r\n                }\r\n            });\r\n            showButtons();\r\n            hideTimeout = setTimeout(() => {\r\n                BUTTON_CONTAINER.classList.add('hidden');\r\n            }, 2000);\r\n        }\r\n\r\n        function handleOutlinePaneMouseDown(e) {\r\n            if (e.detail === 2) e.preventDefault(); // Prevent text selection on double-click\r\n        }\r\n\r\n        function handleOutlinePaneClick(event) {\r\n            const nodeEl = event.target.closest('.node');\r\n            if (!nodeEl) return;\r\n\r\n            const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);\r\n            if (rowIndex < 0 || rowIndex >= flatRows.length) return;\r\n\r\n            const row = flatRows[rowIndex];\r\n\r\n            // Handle different click targets\r\n            if (event.target.classList.contains('caret') && row.hasChildren) {\r\n                event.stopPropagation();\r\n                MENU.style.display = \"none\"; // Close possible existing right-click menu\r\n\r\n                // Both toggle and select in one operation\r\n                selectAndOrToggleAndRedraw(\r\n                    row.node !== selectedNode ? row.node : null,\r\n                    row.node\r\n                );\r\n            } else {\r\n                // Rest of the node (including icon and text)\r\n                event.stopPropagation();\r\n                MENU.style.display = \"none\"; // Close possible existing right-click menu\r\n\r\n                if (row.node !== selectedNode) {\r\n                    selectAndOrToggleAndRedraw(row.node); // Just selection\r\n                }\r\n            }\r\n        }\r\n\r\n        function handleOutlinePaneDblClick(event) {\r\n            if (event.target.classList.contains('node-text')) {\r\n                event.preventDefault();\r\n                event.stopPropagation();\r\n\r\n                const nodeEl = event.target.closest('.node');\r\n                if (!nodeEl) return;\r\n\r\n                const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);\r\n                if (rowIndex >= 0 && rowIndex < flatRows.length) {\r\n                    const row = flatRows[rowIndex];\r\n                    if (row.hasChildren) {\r\n                        // Handle both selection and toggle in one update\r\n                        selectAndOrToggleAndRedraw(\r\n                            row.node !== selectedNode ? row.node : null,\r\n                            row.node\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function handleContextMenu(e) {\r\n            e.preventDefault();\r\n            const nodeEl = e.target.closest('.node');\r\n            if (!nodeEl) {\r\n                // close possible existing right-click menu\r\n                MENU.style.display = 'none';\r\n                return;\r\n            }\r\n\r\n            const rowIndex = Math.floor(parseInt(nodeEl.style.top) / ROW_HEIGHT);\r\n            if (rowIndex < 0 || rowIndex >= flatRows.length) return;\r\n            const row = flatRows[rowIndex];\r\n\r\n            // Select the node if not already selected\r\n            if (row.node !== selectedNode) {\r\n                selectAndOrToggleAndRedraw(row.node);\r\n            }\r\n\r\n            console.log('Context menu on node:', row.node);\r\n\r\n            // Position and show the custom context menu\r\n            MENU.style.top = `${e.clientY}px`;\r\n            MENU.style.left = `${e.clientX}px`;\r\n            MENU.style.display = 'block';\r\n        }\r\n\r\n        function handleOutlinePaneKeyDown(e) {\r\n            const handler = outlinePaneKeyMap[e.key];\r\n            if (handler && !e.ctrlKey && !e.altKey && !e.metaKey) {\r\n                e.preventDefault();\r\n                handler();\r\n            }\r\n        }\r\n\r\n        function handleBodyPaneKeyDown(e) {\r\n            if (e.key === 'Tab') {\r\n                e.preventDefault();\r\n                OUTLINE_PANE.focus();\r\n            }\r\n        }\r\n\r\n        // Global key handlers (work anywhere)\r\n        function handleGlobalKeyDown(e) {\r\n            if (e.key.toLowerCase() === 'f' && e.ctrlKey && !e.altKey && !e.metaKey) {\r\n                e.preventDefault();\r\n                startFind();\r\n            } else if (e.key.toLowerCase() === 'm' && e.ctrlKey && !e.altKey && !e.metaKey) {\r\n                e.preventDefault();\r\n                toggleMarkCurrentNode();\r\n            } else if (e.key === 'F2') {\r\n                e.preventDefault();\r\n                findPrevious();\r\n            } else if (e.key === 'F3') {\r\n                e.preventDefault();\r\n                findNext();\r\n            } else if (e.key === '-' && e.altKey && !e.ctrlKey && !e.metaKey) {\r\n                e.preventDefault();\r\n                collapseAll();\r\n            } else if (e.altKey && !e.ctrlKey && !e.metaKey) {\r\n                // Handle Alt+Arrow keys globally\r\n                switch (e.key) {\r\n                    case 'ArrowUp':\r\n                        e.preventDefault();\r\n                        OUTLINE_PANE.focus();\r\n                        selectVisBack();\r\n                        break;\r\n                    case 'ArrowDown':\r\n                        e.preventDefault();\r\n                        OUTLINE_PANE.focus();\r\n                        selectVisNext();\r\n                        break;\r\n                    case 'ArrowLeft':\r\n                        e.preventDefault();\r\n                        OUTLINE_PANE.focus();\r\n                        contractNodeOrGoToParent();\r\n                        break;\r\n                    case 'ArrowRight':\r\n                        e.preventDefault();\r\n                        OUTLINE_PANE.focus();\r\n                        expandNodeAndGoToFirstChild();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        function handleWindowResize() {\r\n            updatePanelSizes();\r\n            renderTree();\r\n        }\r\n\r\n        function handleDOMContentLoaded() {\r\n            loadConfigPreferences();\r\n\r\n            const initialSelectedNode = loadDocumentStateFromLocalStorage();\r\n            if (!initialSelectedNode) {\r\n                selectAndOrToggleAndRedraw(tree.children[0]); // sets selectedNode amd flatRows\r\n            } else {\r\n                selectAndOrToggleAndRedraw(initialSelectedNode); // sets selectedNode amd flatRows\r\n            }\r\n            setupButtonContainerAutoHide();\r\n            updateMarkedButtonStates();\r\n        }\r\n\r\n        function handleThemeToggleClick() {\r\n            // Only animate once button pressed, so page-load wont animate color changes.\r\n            HTML_ELEMENT.setAttribute('data-transition', 'true');\r\n            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\r\n            applyTheme(newTheme);\r\n            renderTree(); // Re-render to update icon colors\r\n        }\r\n\r\n        function handleLayoutToggleClick() {\r\n            HTML_ELEMENT.setAttribute('data-transition', 'true');\r\n            const newLayout = currentLayout === 'vertical' ? 'horizontal' : 'vertical';\r\n            applyLayout(newLayout);\r\n        }\r\n\r\n        function updateButtonVisibility() {\r\n            toggleButtonVisibility(NEXT_MARKED_BTN, PREV_MARKED_BTN, SHOW_PREV_NEXT_MARK.checked && marked.size > 0);\r\n            toggleButtonVisibility(TOGGLE_MARK_BTN, null, SHOW_TOGGLE_MARK.checked);\r\n            toggleButtonVisibility(NEXT_BTN, PREV_BTN, SHOW_PREV_NEXT_HISTORY.checked && navigationHistory.length > 1);\r\n            toggleButtonVisibility(HOIST_BTN, DEHOIST_BTN, SHOW_HOIST_DEHOIST.checked);\r\n            toggleButtonVisibility(LAYOUT_TOGGLE, null, SHOW_LAYOUT_ORIENTATION.checked);\r\n            toggleButtonVisibility(THEME_TOGGLE, null, SHOW_THEME_TOGGLE.checked);\r\n            toggleButtonVisibility(COLLAPSE_ALL_BTN, null, SHOW_COLLAPSE_ALL.checked);\r\n            let visibleButtonCount = 0; // Count visible buttons to adjust trigger area width\r\n            if (SHOW_PREV_NEXT_MARK.checked && marked.size > 0) {\r\n                visibleButtonCount += 2;\r\n            }\r\n            if (SHOW_TOGGLE_MARK.checked) {\r\n                visibleButtonCount += 1;\r\n            }\r\n            if (SHOW_PREV_NEXT_HISTORY.checked && navigationHistory.length > 1) {\r\n                visibleButtonCount += 2;\r\n            }\r\n            if (SHOW_HOIST_DEHOIST.checked) {\r\n                visibleButtonCount += 2;\r\n            }\r\n            if (SHOW_LAYOUT_ORIENTATION.checked) {\r\n                visibleButtonCount += 1;\r\n            }\r\n            if (SHOW_THEME_TOGGLE.checked) {\r\n                visibleButtonCount += 1;\r\n            }\r\n            TRIGGER_AREA.style.width = ((visibleButtonCount * 40) + 10) + 'px';\r\n        }\r\n\r\n        function updateNodeIcons() {\r\n            HTML_ELEMENT.setAttribute('data-show-icons', SHOW_NODE_ICONS.checked ? 'true' : 'false');\r\n            renderTree(); // Re-render to apply icon changes\r\n        }\r\n\r\n        function toggleButtonVisibility(button1, button2, isVisible) {\r\n            if (button1) {\r\n                button1.classList.toggle('hidden-button', !isVisible);\r\n            }\r\n            if (button2) {\r\n                button2.classList.toggle('hidden-button', !isVisible);\r\n            }\r\n        }\r\n\r\n        function saveAll() {\r\n            saveLayoutPreferences();\r\n            saveConfigPreferences();\r\n            saveDocumentStateToLocalStorage();\r\n        }\r\n\r\n        function saveDocumentStateToLocalStorage() {\r\n            // Use the allNodesInOrder tree, the full list from the top as if all nodes were expanded,\r\n            // to note the position of hoisted node(s), expanded node(s), and the currently selected node.\r\n            let hoistStackPositions = []; // empty means no hoist\r\n            for (const hoisted of hoistStack) {\r\n                const pos = allNodesInOrder.indexOf(hoisted);\r\n                if (pos !== -1) {\r\n                    hoistStackPositions.push(pos);\r\n                }\r\n            }\r\n            const expandedPositions = [];\r\n            for (const node of expanded) {\r\n                const pos = allNodesInOrder.indexOf(node);\r\n                if (pos !== -1) {\r\n                    expandedPositions.push(pos);\r\n                }\r\n            }\r\n            const selectedPosition = allNodesInOrder.indexOf(selectedNode); // -1 means no selection\r\n            const markedArray = Array.from(marked); // Marked are the gnx keys, not numeric positions from allNodesInOrder\r\n            const dataToSave = {\r\n                marked: markedArray,\r\n                hoistStack: hoistStackPositions,\r\n                selected: selectedPosition,\r\n                expanded: expandedPositions\r\n            };\r\n            safeLocalStorageSet(title + genTimestamp, JSON.stringify(dataToSave)); // Key is title + genTimestamp\r\n        }\r\n\r\n        function loadDocumentStateFromLocalStorage() {\r\n            // returns the selected node if found, otherwise null\r\n            let initialSelectedNode = null;\r\n            const savedData = safeLocalStorageGet(title + genTimestamp); // Key is title + genTimestamp\r\n            if (savedData) {\r\n                try {\r\n                    const parsedData = JSON.parse(savedData);\r\n                    // Start by rebuilding marked set and their related node icons\r\n                    if (parsedData && Array.isArray(parsedData.marked)) {\r\n                        marked.clear();\r\n                        parsedData.marked.forEach(gnx => {\r\n                            marked.add(gnx);\r\n                            // Update icon state to reflect marked status\r\n                            if (data[gnx]) {\r\n                                data[gnx].icon = (data[gnx].icon || 0) | 2; // Set marked bit\r\n                            }\r\n                        });\r\n                    }\r\n                    // If document stated data is found, rebuild hoist stack, expanded set, and selected node\r\n                    if (parsedData && Array.isArray(parsedData.expanded) && Array.isArray(parsedData.hoistStack) && typeof parsedData.selected === 'number') {\r\n                        const expandedPositions = parsedData.expanded;\r\n                        const hoistPositions = parsedData.hoistStack;\r\n                        const selectedPosition = parsedData.selected;\r\n                        for (const hoisted of hoistPositions) {\r\n                            if (hoisted >= 0 && hoisted < allNodesInOrder.length) {\r\n                                hoistStack.push(allNodesInOrder[hoisted]);\r\n                            }\r\n                        }\r\n                        for (const node of expandedPositions) {\r\n                            if (node >= 0 && node < allNodesInOrder.length) {\r\n                                expanded.add(allNodesInOrder[node]);\r\n                            }\r\n                        }\r\n                        if (selectedPosition >= 0 && selectedPosition < allNodesInOrder.length) {\r\n                            initialSelectedNode = allNodesInOrder[selectedPosition];\r\n                        }\r\n                    }\r\n                    return initialSelectedNode;\r\n                } catch (e) {\r\n                    console.error('Error loading document state from localStorage:', e);\r\n                }\r\n            }\r\n        }\r\n\r\n        function saveLayoutPreferences() {\r\n            const layoutPreferences = {\r\n                mainRatio: mainRatio,\r\n                secondaryRatio: secondaryRatio,\r\n                theme: currentTheme,\r\n                layout: currentLayout\r\n            };\r\n            safeLocalStorageSet('layoutPreferences', JSON.stringify(layoutPreferences));\r\n        }\r\n\r\n        function saveConfigPreferences() {\r\n            const selectedFindScope = document.querySelector('input[name=\"find-scope\"]:checked')?.value || 'entire';\r\n\r\n            const preferences = {\r\n                showPrevNextMark: SHOW_PREV_NEXT_MARK.checked,\r\n                showToggleMark: SHOW_TOGGLE_MARK.checked,\r\n                showPrevNextHistory: SHOW_PREV_NEXT_HISTORY.checked,\r\n                showHoistDehoist: SHOW_HOIST_DEHOIST.checked,\r\n                showLayoutOrientation: SHOW_LAYOUT_ORIENTATION.checked,\r\n                showThemeToggle: SHOW_THEME_TOGGLE.checked,\r\n                showNodeIcons: SHOW_NODE_ICONS.checked,\r\n                showCollapseAll: SHOW_COLLAPSE_ALL.checked,\r\n                // Find-pane options\r\n                findWholeWord: OPT_WHOLE.checked,\r\n                findIgnoreCase: OPT_IGNORECASE.checked,\r\n                findRegexp: OPT_REGEXP.checked,\r\n                findMark: OPT_MARK.checked,\r\n                findHeadline: OPT_HEADLINE.checked,\r\n                findBody: OPT_BODY.checked,\r\n                findScope: selectedFindScope\r\n            };\r\n            safeLocalStorageSet('configPreferences', JSON.stringify(preferences));\r\n        }\r\n\r\n        function loadThemeAndLayoutPreferences() {\r\n            const savedPrefs = safeLocalStorageGet('layoutPreferences');\r\n            if (savedPrefs) {\r\n                try {\r\n                    const prefs = JSON.parse(savedPrefs);\r\n                    if (typeof prefs.mainRatio === 'number') {\r\n                        mainRatio = prefs.mainRatio;\r\n                    }\r\n                    if (typeof prefs.secondaryRatio === 'number') {\r\n                        secondaryRatio = prefs.secondaryRatio;\r\n                    }\r\n                    if (prefs.theme) {\r\n                        applyTheme(prefs.theme);\r\n                    }\r\n                    if (prefs.layout) {\r\n                        applyLayout(prefs.layout);\r\n                    }\r\n                } catch (e) {\r\n                    console.error('Error loading layout preferences:', e);\r\n                }\r\n            } else {\r\n                applyTheme(currentTheme);\r\n                applyLayout(currentLayout);\r\n            }\r\n        }\r\n\r\n        function loadConfigPreferences() {\r\n            const savedPrefs = safeLocalStorageGet('configPreferences');\r\n            if (savedPrefs) {\r\n                try {\r\n                    const prefs = JSON.parse(savedPrefs);\r\n                    SHOW_PREV_NEXT_MARK.checked = prefs.showPrevNextMark ?? false;\r\n                    SHOW_TOGGLE_MARK.checked = prefs.showToggleMark ?? false;\r\n                    SHOW_PREV_NEXT_HISTORY.checked = prefs.showPrevNextHistory ?? true;\r\n                    SHOW_HOIST_DEHOIST.checked = prefs.showHoistDehoist ?? false;\r\n                    SHOW_LAYOUT_ORIENTATION.checked = prefs.showLayoutOrientation ?? true;\r\n                    SHOW_THEME_TOGGLE.checked = prefs.showThemeToggle ?? true;\r\n                    SHOW_NODE_ICONS.checked = prefs.showNodeIcons ?? true;\r\n                    SHOW_COLLAPSE_ALL.checked = prefs.showCollapseAll ?? true;\r\n                    // Find-pane options\r\n                    OPT_WHOLE.checked = prefs.findWholeWord ?? OPT_WHOLE.checked;\r\n                    OPT_IGNORECASE.checked = prefs.findIgnoreCase ?? OPT_IGNORECASE.checked;\r\n                    OPT_REGEXP.checked = prefs.findRegexp ?? OPT_REGEXP.checked;\r\n                    OPT_MARK.checked = prefs.findMark ?? OPT_MARK.checked;\r\n                    OPT_HEADLINE.checked = prefs.findHeadline ?? OPT_HEADLINE.checked;\r\n                    OPT_BODY.checked = prefs.findBody ?? OPT_BODY.checked;\r\n                    // Set the find scope radio\r\n                    if (prefs.findScope) {\r\n                        const scopeRadio = document.getElementById('scope-' + prefs.findScope);\r\n                        if (scopeRadio) scopeRadio.checked = true;\r\n                    }\r\n\r\n                    updateButtonVisibility();\r\n                    updateNodeIcons();\r\n                } catch (e) {\r\n                    console.error('Error loading config preferences:', e);\r\n                }\r\n            } else {\r\n                updateButtonVisibility();\r\n                updateNodeIcons();\r\n            }\r\n        }\r\n\r\n        // Find functionality\r\n        function startFind() {\r\n            initialFindNode = null; // If null, find next will set this, used with \"Suboutline Only\" find radio option (value: suboutline)\r\n            if (HTML_ELEMENT.getAttribute('data-show-config') === 'true') {\r\n                toggleConfiguration(); // // Make find input visible if in settings screen\r\n            }\r\n            FIND_INPUT.focus();\r\n            FIND_INPUT.select();\r\n            renderTree(); // To show or remove initial-find highlight\r\n        }\r\n\r\n        function findNext() {\r\n            if (!selectedNode) return; // No selection, nothing to search from\r\n            const searchText = FIND_INPUT.value.trim();\r\n            if (!searchText) {\r\n                showToast('Empty find pattern', 1500);\r\n                return; // Empty search, do nothing\r\n            }\r\n\r\n            const searchInBody = OPT_BODY.checked;\r\n            const searchInHeadlines = OPT_HEADLINE.checked;\r\n            const ignoreCase = OPT_IGNORECASE.checked;\r\n            const isRegexp = OPT_REGEXP.checked;\r\n            const wholeWord = OPT_WHOLE.checked;\r\n            const markFind = OPT_MARK.checked;\r\n\r\n            if (!searchInBody && !searchInHeadlines) {\r\n                showToast('not searching headline or body', 2000);\r\n                return; // Nothing to search in\r\n            }\r\n            if (!initialFindNode) {\r\n                initialFindNode = selectedNode; // Set initial find node if not already set\r\n            }\r\n\r\n            let selectedRadioValue = ''; // Falsy for now\r\n            const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\r\n            if (selectedRadio) {\r\n                selectedRadioValue = selectedRadio.value;\r\n            }\r\n\r\n            let pattern; // Create regex pattern based on search options\r\n            try {\r\n                if (isRegexp) {\r\n                    pattern = searchText;\r\n                } else {\r\n                    pattern = searchText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // Escape special regex characters\r\n                    if (wholeWord) {\r\n                        pattern = '\\\\b' + pattern + '\\\\b'; // Add word boundaries if whole word option is enabled\r\n                    }\r\n                }\r\n                const flags = ignoreCase ? 'gi' : 'g';\r\n                const regex = new RegExp(pattern, flags);\r\n\r\n                const startIndex = allNodesInOrder.indexOf(selectedNode);\r\n                if (startIndex === -1) return;\r\n\r\n                const totalNodes = allNodesInOrder.length;\r\n                let currentIndex = startIndex; // start from current selection\r\n\r\n                while (currentIndex < totalNodes) {\r\n                    const node = allNodesInOrder[currentIndex];\r\n                    if (selectedRadioValue === 'suboutline' && (initialFindNode !== node && isAncestorOf(initialFindNode, node) === false)) {\r\n                        break; // Reached outside suboutline of initialFindNode\r\n                    }\r\n\r\n                    let headString = data[node.gnx]?.headString || \"\";\r\n                    let body = data[node.gnx]?.bodyString || \"\";\r\n\r\n                    // If searching headlines, check there first, but skip if the focus in in the body pane and its the currently selected node\r\n                    if (searchInHeadlines && headString && !(node === selectedNode && findFocus() === 2)) {\r\n                        regex.lastIndex = 0; // Reset regex state\r\n                        let startOffset = 0;\r\n                        // If this is the currently selected node, check for current selection range existing in selectedLabelElement with getSelection()\r\n                        // and only search after that range. Keep that offset, if any, and apply it to the match index later.\r\n                        if (node === selectedNode && selectedLabelElement) {\r\n                            const selection = window.getSelection();\r\n                            if (selection.rangeCount > 0) {\r\n                                const range = selection.getRangeAt(0);\r\n                                if (selectedLabelElement.contains(range.commonAncestorContainer)) {\r\n                                    // Selection is inside the headline span\r\n                                    startOffset = range.endOffset;\r\n                                    headString = headString.substring(startOffset);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        const match = regex.exec(headString);\r\n\r\n                        if (match) {\r\n                            // If 'mark find' is checked, mark the found node if not already marked\r\n                            if (markFind) {\r\n                                if (!marked.has(node.gnx)) {\r\n                                    marked.add(node.gnx);\r\n                                    if (data[node.gnx]) {\r\n                                        data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\r\n                                    }\r\n                                }\r\n                            }\r\n                            selectAndOrToggleAndRedraw(node); // This also calls scrollSelectedNodeIntoView\r\n\r\n                            // Focus outline pane and highlight match\r\n                            if (findFocus() !== 1) {\r\n                                OUTLINE_PANE.focus();\r\n                            }\r\n\r\n                            // Highlight the match in the headline using selectedLabelElement\r\n                            setTimeout(() => {\r\n                                highlightMatchInHeadline(match.index + startOffset, match.index + startOffset + match[0].length);\r\n                            });\r\n\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    if (searchInBody && body) {\r\n                        regex.lastIndex = 0; // Reset regex state\r\n\r\n                        // If this is the currently selected node, check for current selection range existing in BODY_PANE with getSelection()\r\n                        // and only search after that range. Keep that offset, if any, and apply it to the match index later.\r\n                        let startOffset = 0;\r\n                        if (node === selectedNode && BODY_PANE) {\r\n                            const selection = window.getSelection();\r\n                            if (selection.rangeCount > 0) {\r\n                                const range = selection.getRangeAt(0);\r\n                                if (BODY_PANE.contains(range.commonAncestorContainer)) {\r\n                                    // Compute global offset across all text nodes in BODY_PANE\r\n                                    startOffset = getGlobalOffset(BODY_PANE, range.endContainer, range.endOffset);\r\n                                    body = body.substring(startOffset);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        const match = regex.exec(body);\r\n                        if (match) {\r\n                            if (markFind) {\r\n                                if (!marked.has(node.gnx)) {\r\n                                    marked.add(node.gnx);\r\n                                    if (data[node.gnx]) {\r\n                                        data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\r\n                                    }\r\n                                }\r\n                            }\r\n                            selectAndOrToggleAndRedraw(node); // This also calls scrollSelectedNodeIntoView\r\n                            if (findFocus() !== 2) {\r\n                                BODY_PANE.focus();\r\n                            }\r\n                            setTimeout(() => {\r\n                                highlightMatchInBody(match.index + startOffset, match.index + startOffset + match[0].length);\r\n                            });\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (selectedRadioValue === 'nodeonly') {\r\n                        break; // Only search current node\r\n                    }\r\n                    currentIndex++;\r\n                }\r\n\r\n                let searchedParams = [];\r\n                if (searchInHeadlines) searchedParams.push('head');\r\n                if (searchInBody) searchedParams.push('body');\r\n                showToast(`Not found: (${searchedParams.join(\", \")}) ${searchText}`, 1500);\r\n\r\n            } catch (e) {\r\n                showToast('Invalid search pattern: ' + e.message, 2000);\r\n            }\r\n\r\n        }\r\n\r\n        function findPrevious() {\r\n            if (!selectedNode) return; // No selection, nothing to search from\r\n            const searchText = FIND_INPUT.value.trim();\r\n            if (!searchText) {\r\n                showToast('Empty find pattern', 1500);\r\n                return; // Empty search, do nothing\r\n            }\r\n\r\n            const searchInBody = OPT_BODY.checked;\r\n            const searchInHeadlines = OPT_HEADLINE.checked;\r\n            const ignoreCase = OPT_IGNORECASE.checked;\r\n            const isRegexp = OPT_REGEXP.checked;\r\n            const wholeWord = OPT_WHOLE.checked;\r\n            const markFind = OPT_MARK.checked;\r\n\r\n            if (!searchInBody && !searchInHeadlines) {\r\n                showToast('not searching headline or body', 2000);\r\n                return; // Nothing to search in\r\n            }\r\n            if (!initialFindNode) {\r\n                initialFindNode = selectedNode; // Set initial find node if not already set\r\n            }\r\n\r\n            let selectedRadioValue = ''; // Falsy for now\r\n            const selectedRadio = document.querySelector('input[name=\"find-scope\"]:checked');\r\n            if (selectedRadio) {\r\n                selectedRadioValue = selectedRadio.value;\r\n            }\r\n\r\n            let pattern; // Create regex pattern based on search options\r\n            try {\r\n                if (isRegexp) {\r\n                    pattern = searchText;\r\n                } else {\r\n                    pattern = searchText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // Escape special regex characters\r\n                    if (wholeWord) {\r\n                        pattern = '\\\\b' + pattern + '\\\\b'; // Add word boundaries if whole word option is enabled\r\n                    }\r\n                }\r\n                const flags = ignoreCase ? 'gi' : 'g';\r\n                const regex = new RegExp(pattern, flags);\r\n\r\n                const startIndex = allNodesInOrder.indexOf(selectedNode);\r\n                if (startIndex === -1) return;\r\n\r\n                // Helper function to find the last match in a string\r\n                function findLastMatch(str) {\r\n                    let lastMatchIndex = -1;\r\n                    let lastMatchLength = 0;\r\n\r\n                    let match;\r\n                    while ((match = regex.exec(str)) !== null) {\r\n                        lastMatchIndex = match.index;\r\n                        lastMatchLength = match[0].length;\r\n                        // Prevent infinite loop for zero-width matches\r\n                        if (regex.lastIndex === match.index) regex.lastIndex++;\r\n                    }\r\n\r\n                    return lastMatchIndex !== -1 ? { index: lastMatchIndex, length: lastMatchLength } : null;\r\n                }\r\n\r\n                // Flag to track if we found a match in the current node\r\n                let foundMatchInCurrentNode = false;\r\n\r\n                // First, check the current node with respect to the current selection\r\n                const node = selectedNode;\r\n                let headString = data[node.gnx]?.headString || \"\";\r\n                let body = data[node.gnx]?.bodyString || \"\";\r\n\r\n                // Get current selection info\r\n                const selection = window.getSelection();\r\n                let headlineOffset = Infinity;\r\n                let bodyOffset = Infinity;\r\n\r\n                if (selection.rangeCount > 0) {\r\n                    const range = selection.getRangeAt(0);\r\n                    if (selectedLabelElement && selectedLabelElement.contains(range.commonAncestorContainer)) {\r\n                        // Selection is in headline\r\n                        headlineOffset = range.startOffset;\r\n                    } else if (BODY_PANE.contains(range.commonAncestorContainer)) {\r\n                        // Selection is in body — compute global offset across text nodes\r\n                        bodyOffset = getGlobalOffset(BODY_PANE, range.startContainer, range.startOffset);\r\n                    }\r\n                }\r\n\r\n                const currentFocus = findFocus();\r\n\r\n                // Check current node based on focus\r\n                if (currentFocus === 2 && searchInBody && body) {\r\n                    // If focused in body, check body first\r\n                    const limitedBody = body.substring(0, bodyOffset);\r\n                    const match = findLastMatch(limitedBody);\r\n\r\n                    if (match) {\r\n                        if (markFind && !marked.has(node.gnx)) {\r\n                            marked.add(node.gnx);\r\n                            if (data[node.gnx]) {\r\n                                data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\r\n                            }\r\n                        }\r\n                        selectAndOrToggleAndRedraw(node);\r\n                        BODY_PANE.focus();\r\n                        setTimeout(() => {\r\n                            highlightMatchInBody(match.index, match.index + match.length);\r\n                        });\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                // Check headline if appropriate\r\n                if (searchInHeadlines && headString) {\r\n                    const limitedHeadline = currentFocus !== 2 ? headString.substring(0, headlineOffset) : headString;\r\n                    const match = findLastMatch(limitedHeadline);\r\n\r\n                    if (match) {\r\n                        if (markFind && !marked.has(node.gnx)) {\r\n                            marked.add(node.gnx);\r\n                            if (data[node.gnx]) {\r\n                                data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\r\n                            }\r\n                        }\r\n                        selectAndOrToggleAndRedraw(node);\r\n                        OUTLINE_PANE.focus();\r\n                        setTimeout(() => {\r\n                            highlightMatchInHeadline(match.index, match.index + match.length);\r\n                        });\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                // Continue searching through previous nodes if no match was found in current node\r\n                let currentIndex = startIndex - 1;\r\n\r\n                while (currentIndex >= 0) {\r\n                    const node = allNodesInOrder[currentIndex];\r\n                    if (selectedRadioValue === 'nodeonly') {\r\n                        break; // Only search current node\r\n                    }\r\n                    if (selectedRadioValue === 'suboutline' && (initialFindNode !== node && isAncestorOf(initialFindNode, node) === false)) {\r\n                        break; // Reached outside suboutline of initialFindNode\r\n                    }\r\n                    let headString = data[node.gnx]?.headString || \"\";\r\n                    let body = data[node.gnx]?.bodyString || \"\";\r\n\r\n                    // In previous nodes, check body first (since we're going backward)\r\n                    if (searchInBody && body) {\r\n                        const match = findLastMatch(body);\r\n                        if (match) {\r\n                            if (markFind && !marked.has(node.gnx)) {\r\n                                marked.add(node.gnx);\r\n                                if (data[node.gnx]) {\r\n                                    data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\r\n                                }\r\n                            }\r\n                            selectAndOrToggleAndRedraw(node);\r\n                            BODY_PANE.focus();\r\n                            setTimeout(() => {\r\n                                highlightMatchInBody(match.index, match.index + match.length);\r\n                            });\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    // Then check headline\r\n                    if (searchInHeadlines && headString) {\r\n                        const match = findLastMatch(headString);\r\n\r\n                        if (match) {\r\n                            if (markFind && !marked.has(node.gnx)) {\r\n                                marked.add(node.gnx);\r\n                                if (data[node.gnx]) {\r\n                                    data[node.gnx].icon = (data[node.gnx].icon || 0) | 2; // Set marked bit\r\n                                }\r\n                            }\r\n\r\n                            selectAndOrToggleAndRedraw(node);\r\n                            OUTLINE_PANE.focus();\r\n                            setTimeout(() => {\r\n                                highlightMatchInHeadline(match.index, match.index + match.length);\r\n                            });\r\n                            return;\r\n                        }\r\n                    }\r\n                    currentIndex--;\r\n                }\r\n\r\n                let searchedParams = [];\r\n                if (searchInHeadlines) searchedParams.push('head');\r\n                if (searchInBody) searchedParams.push('body');\r\n                showToast(`Not found: (${searchedParams.join(\", \")}) ${searchText}`, 1500);\r\n            } catch (e) {\r\n                showToast('Invalid search pattern: ' + e.message, 2000);\r\n            }\r\n        }\r\n\r\n        function highlightMatchInHeadline(startIndex, endIndex) {\r\n            // Use the global selectedLabelElement which is already set after selectAndOrToggleAndRedraw\r\n            if (!selectedLabelElement) return;\r\n            // Find the first text node in the label element\r\n            let textNode = null;\r\n            for (const node of selectedLabelElement.childNodes) {\r\n                if (node.nodeType === Node.TEXT_NODE) {\r\n                    textNode = node;\r\n                    break;\r\n                }\r\n            }\r\n            if (!textNode) return;\r\n            try {\r\n                const range = document.createRange();\r\n                range.setStart(textNode, startIndex);\r\n                range.setEnd(textNode, endIndex);\r\n\r\n                const selection = window.getSelection();\r\n                selection.removeAllRanges();\r\n                selection.addRange(range);\r\n            } catch (e) {\r\n                console.error('Error setting headline selection:', e);\r\n            }\r\n        }\r\n\r\n        function highlightMatchInBody(startIndex, endIndex) {\r\n            // The body pane content is set directly as textContent, so it's a single text node\r\n            if (!BODY_PANE.firstChild) return;\r\n            try {\r\n                const range = document.createRange();\r\n                const start = getTextNodeAtIndex(BODY_PANE, startIndex);\r\n                const end = getTextNodeAtIndex(BODY_PANE, endIndex);\r\n\r\n                if (!start || !end) {\r\n                    console.warn(\"Invalid range: could not resolve text nodes\");\r\n                    return;\r\n                }\r\n\r\n                range.setStart(start.node, start.offset);\r\n                range.setEnd(end.node, end.offset);\r\n\r\n                const sel = window.getSelection();\r\n                sel.removeAllRanges();\r\n                sel.addRange(range);\r\n            } catch (e) {\r\n                console.error('Error setting body selection:', e);\r\n            }\r\n        }\r\n\r\n        function getTextNodeAtIndex(root, index) {\r\n            const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);\r\n            let currentNode = walker.nextNode();\r\n            let remaining = index;\r\n\r\n            while (currentNode) {\r\n                const len = currentNode.nodeValue.length;\r\n                if (remaining <= len) {\r\n                    return { node: currentNode, offset: remaining };\r\n                }\r\n                remaining -= len;\r\n                currentNode = walker.nextNode();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function getGlobalOffset(root, container, offset) {\r\n            const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);\r\n            let total = 0;\r\n            let current = walker.nextNode();\r\n\r\n            while (current) {\r\n                if (current === container) {\r\n                    return total + offset;\r\n                }\r\n                total += current.nodeValue.length;\r\n                current = walker.nextNode();\r\n            }\r\n            return total;\r\n        }\r\n\r\n        function findFocus() {\r\n            // Returns 1 if focus in outline-pane, 2 if in body-pane, 0 otherwise\r\n            if (document.activeElement === OUTLINE_PANE || OUTLINE_PANE.contains(document.activeElement)) {\r\n                return 1;\r\n            } else if (document.activeElement === BODY_PANE || BODY_PANE.contains(document.activeElement)) {\r\n                return 2;\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        function initializeThemeAndLayout() {\r\n            document.title = title; // Set the document title\r\n            loadThemeAndLayoutPreferences();\r\n            updateMarkedButtonStates();\r\n            updateHoistButtonStates();\r\n            setupEventHandlers();\r\n            setupButtonFocusPrevention();\r\n        }\r\n\r\n        // Apply theme & layout before anything else to avoid flash of unstyled content\r\n        initializeThemeAndLayout(); // gets ratios from localStorage and applies layout and theme\r\n        // Start everything once DOM is loaded\r\n        window.addEventListener('DOMContentLoaded', handleDOMContentLoaded);\r\n\r\n    </script>\r\n</body>\r\n\r\n</html>";
